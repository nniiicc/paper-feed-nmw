{"version":3,"file":"content-script.js","sources":["../../utils/logger.ts","../../source-integration/link-processor.ts","../../source-integration/metadata-extractor.ts","../../source-integration/base-source.ts","../../source-integration/arxiv/index.ts","../../source-integration/openreview/index.ts","../../source-integration/nature/index.ts","../../source-integration/pnas/index.ts","../../source-integration/sciencedirect/index.ts","../../source-integration/springer/index.ts","../../source-integration/ieee/index.ts","../../source-integration/acm/index.ts","../../source-integration/acl/index.ts","../../source-integration/neurips/index.ts","../../source-integration/cvf/index.ts","../../source-integration/wiley/index.ts","../../source-integration/plos/index.ts","../../source-integration/biorxiv/index.ts","../../source-integration/medrxiv/index.ts","../../source-integration/ssrn/index.ts","../../source-integration/semanticscholar/index.ts","../../source-integration/misc/index.ts","../../source-integration/registry.ts","../../content.ts"],"sourcesContent":["// utils/logger.ts\n// Logging utility wrapping loguru\n\n/**\n * Logger class for consistent logging throughout the extension\n */\nexport class Logger {\n  constructor(private module: string) {}\n  \n  /**\n   * Log debug message\n   */\n  debug(message: string, data?: any): void {\n    console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n  \n  /**\n   * Log info message\n   */\n  info(message: string, data?: any): void {\n    console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n  \n  /**\n   * Log warning message\n   */\n  warning(message: string, data?: any): void {\n    console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n\n  /**\n   * Alias for warning method (to match loguru API)\n   */\n  warn(message: string, data?: any): void {\n    this.warning(message, data);\n  }\n  \n  /**\n   * Log error message\n   */\n  error(message: string, data?: any): void {\n    console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');\n  }\n}\n\n/**\n * Loguru mock for browser extension use\n */\nclass LoguruMock {\n  /**\n   * Get logger for a module\n   */\n  getLogger(module: string): Logger {\n    return new Logger(module);\n  }\n}\n\n// Export singleton instance\nexport const loguru = new LoguruMock();\n","// extension/source-integration/link-processor.ts\n// Generic link detection and processing module\n\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('link-processor');\n\ninterface LinkPattern {\n  // Source integration ID\n  sourceId: string;\n  \n  // Regular expression to match URLs\n  pattern: RegExp;\n  \n  // Function to extract paper ID from URL\n  extractPaperId: (url: string) => string | null;\n}\n\nexport class LinkProcessor {\n  private patterns: LinkPattern[] = [];\n  private observer: MutationObserver | null = null;\n  private processedLinks = new Set<string>();\n  private onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void;\n  \n  constructor(onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void) {\n    this.onLinkFound = onLinkFound;\n    logger.debug('Link processor initialized');\n  }\n  \n  /**\n   * Register a new link pattern\n   */\n  registerPattern(pattern: LinkPattern): void {\n    this.patterns.push(pattern);\n    logger.debug(`Registered pattern for ${pattern.sourceId}`);\n  }\n  \n  /**\n   * Process all links in the document\n   */\n  processLinks(document: Document): void {\n    // Process all links in the document\n    const links = document.querySelectorAll<HTMLAnchorElement>('a[href]');\n    \n    links.forEach(link => {\n      // Use a unique identifier for this link\n      const linkId = this.getLinkId(link);\n      \n      // Skip if already processed\n      if (this.processedLinks.has(linkId)) {\n        return;\n      }\n      \n      this.processedLinks.add(linkId);\n      \n      // Check each pattern\n      for (const pattern of this.patterns) {\n        if (pattern.pattern.test(link.href)) {\n          const paperId = pattern.extractPaperId(link.href);\n          \n          if (paperId) {\n            // Call the callback\n            this.onLinkFound(pattern.sourceId, paperId, link);\n            break; // Stop after first match\n          }\n        }\n      }\n    });\n  }\n  \n  /**\n   * Start observing for DOM changes\n   */\n  startObserving(document: Document): void {\n    if (this.observer) {\n      this.observer.disconnect();\n    }\n    \n    this.observer = new MutationObserver((mutations) => {\n      let newLinks = false;\n      \n      mutations.forEach(mutation => {\n        mutation.addedNodes.forEach(node => {\n          if (node.nodeType === Node.ELEMENT_NODE) {\n            // If this is an anchor tag, check it\n            if ((node as Element).tagName === 'A') {\n              newLinks = true;\n            }\n            \n            // Check for any anchor tags within this element\n            const links = (node as Element).querySelectorAll('a[href]');\n            if (links.length > 0) {\n              newLinks = true;\n            }\n          }\n        });\n      });\n      \n      if (newLinks) {\n        this.processLinks(document);\n      }\n    });\n    \n    this.observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n    \n    logger.debug('Started observing for DOM changes');\n  }\n  \n  /**\n   * Create a unique ID for a link\n   */\n  private getLinkId(link: HTMLAnchorElement): string {\n    // Use href and position in document to create a unique ID\n    const path = this.getElementPath(link);\n    return `${link.href}|${path}`;\n  }\n  \n  /**\n   * Get element path in DOM for identification\n   */\n  private getElementPath(element: Element): string {\n    const path: string[] = [];\n    let current: Element | null = element;\n    \n    while (current && current !== document.body) {\n      let selector = current.tagName.toLowerCase();\n      \n      if (current.id) {\n        selector += `#${current.id}`;\n      } else {\n        const siblings = Array.from(current.parentElement?.children || []);\n        const index = siblings.indexOf(current) + 1;\n        if (siblings.length > 1) {\n          selector += `:nth-child(${index})`;\n        }\n      }\n      \n      path.unshift(selector);\n      current = current.parentElement;\n    }\n    \n    return path.join(' > ');\n  }\n  \n  /**\n   * Stop observing DOM changes\n   */\n  stopObserving(): void {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = null;\n      logger.debug('Stopped observing DOM changes');\n    }\n  }\n}\n","// extension/source-integration/metadata-extractor.ts\n// Object-oriented metadata extraction system with customizable extraction methods\n\nimport { loguru } from '../utils/logger';\n\nconst logger = loguru.getLogger('metadata-extractor');\n\nexport interface ExtractedMetadata {\n  title: string;\n  authors: string;\n  description: string;\n  publishedDate: string;\n  doi?: string;\n  journalName?: string;\n  tags?: string[];\n  url?: string;\n}\n\n// Constants for standard source types\nexport const SOURCE_TYPES = {\n  PDF: 'pdf',\n  URL: 'url',\n} as const;\n\nexport type SourceType = typeof SOURCE_TYPES[keyof typeof SOURCE_TYPES];\n\n/**\n * Base class for metadata extraction with customizable extraction methods\n * Each method can be overridden to provide source-specific extraction\n */\nexport class MetadataExtractor {\n  protected document: Document;\n  protected url: string;\n  \n  /**\n   * Create a new metadata extractor for a document\n   */\n  constructor(document: Document) {\n    this.document = document;\n    this.url = document.location.href;\n    logger.debug('Initialized metadata extractor for:', this.url);\n  }\n  \n  /**\n   * Helper method to get content from meta tags\n   */\n  protected getMetaContent(selector: string): string {\n    const element = this.document.querySelector(selector);\n    return element ? element.getAttribute('content') || '' : '';\n  }\n  \n  /**\n   * Extract and return all metadata fields\n   */\n  public extract(): ExtractedMetadata {\n    logger.debug('Extracting metadata from page:', this.url);\n    \n    const metadata: ExtractedMetadata = {\n      title: this.extractTitle(),\n      authors: this.extractAuthors(),\n      description: this.extractDescription(),\n      publishedDate: this.extractPublishedDate(),\n      doi: this.extractDoi(),\n      journalName: this.extractJournalName(),\n      tags: this.extractTags(),\n      url: this.url\n    };\n    \n    logger.debug('Metadata extraction complete:', metadata);\n    return metadata;\n  }\n  \n  /**\n   * Extract title from document\n   * Considers multiple metadata standards with priority order, then DOM fallbacks\n   */\n  protected extractTitle(): string {\n    // Title extraction from meta tags - priority order\n    const metaTitle = (\n      // Dublin Core\n      this.getMetaContent('meta[name=\"DC.Title\"]') || this.getMetaContent('meta[name=\"dc.title\"]') ||\n      // Citation\n      this.getMetaContent('meta[name=\"citation_title\"]') ||\n      // Open Graph\n      this.getMetaContent('meta[property=\"og:title\"]') ||\n      // Standard meta\n      this.getMetaContent('meta[name=\"title\"]')\n    );\n\n    if (metaTitle) {\n      return metaTitle;\n    }\n\n    // DOM-based fallback extraction\n    // Look for common paper title patterns in the page\n    const titleSelectors = [\n      // Common academic page patterns\n      'h1.title', 'h1.article-title', 'h1.paper-title', 'h1.document-title',\n      '.title h1', '.article-title h1', '.paper-title h1',\n      'h1[itemprop=\"headline\"]', 'h1[itemprop=\"name\"]',\n      '.citation_title', '.paper-title', '.article-title',\n      // Generic heading patterns\n      'article h1', 'main h1', '.content h1', '#content h1',\n      // PDF viewer fallbacks\n      '.page-title', '#title',\n      // First h1 on the page as last resort before document.title\n      'h1'\n    ];\n\n    for (const selector of titleSelectors) {\n      const element = this.document.querySelector(selector);\n      if (element) {\n        const text = element.textContent?.trim();\n        // Only use if it looks like a real title (not too short, not navigation)\n        if (text && text.length > 5 && text.length < 500) {\n          return text;\n        }\n      }\n    }\n\n    // Fallback to document title\n    return this.document.title;\n  }\n  \n  /**\n   * Extract authors from document\n   * Handles multiple author formats and sources with DOM fallbacks\n   */\n  protected extractAuthors(): string {\n    // Get all citation authors (some pages have multiple citation_author tags)\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    // Get all DC creators\n    const dcCreators: string[] = [];\n    this.document.querySelectorAll('meta[name=\"DC.Creator.PersonalName\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) dcCreators.push(content);\n    });\n\n    // Individual author elements\n    const dcCreator = this.getMetaContent('meta[name=\"DC.Creator.PersonalName\"]') || this.getMetaContent('meta[name=\"dc.creator.personalname\"]');\n    const citationAuthor = this.getMetaContent('meta[name=\"citation_author\"]');\n    const ogAuthor = this.getMetaContent('meta[property=\"og:article:author\"]') ||\n                    this.getMetaContent('meta[name=\"author\"]');\n\n    // Set authors with priority from meta tags\n    if (dcCreators.length > 0) {\n      return dcCreators.join(', ');\n    } else if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    } else if (dcCreator) {\n      return dcCreator;\n    } else if (citationAuthor) {\n      return citationAuthor;\n    } else if (ogAuthor) {\n      return ogAuthor;\n    }\n\n    // DOM-based fallback extraction\n    const authorSelectors = [\n      // Common academic page patterns\n      '.authors a', '.author a', '.author-name a',\n      '.authors', '.author', '.author-name', '.author-list',\n      '[itemprop=\"author\"]', '[rel=\"author\"]',\n      '.byline', '.by-line', '.article-author', '.paper-author',\n      '.contributor', '.contributors',\n      // arXiv-like patterns\n      '.authors', '.authors-list',\n      // IEEE/ACM patterns\n      '.authors-info .author span', '.author-info',\n      // Nature/Science patterns\n      '.c-article-author-list', '.article-authors',\n      // Generic patterns\n      '.meta-authors', '#authors', '.author-block'\n    ];\n\n    for (const selector of authorSelectors) {\n      const elements = this.document.querySelectorAll(selector);\n      if (elements.length > 0) {\n        const authors: string[] = [];\n        elements.forEach(el => {\n          const text = el.textContent?.trim();\n          if (text && text.length > 1 && text.length < 200) {\n            // Clean up common prefixes\n            const cleaned = text\n              .replace(/^(by|authors?:?|written by)\\s*/i, '')\n              .replace(/\\s+/g, ' ')\n              .trim();\n            if (cleaned) {\n              authors.push(cleaned);\n            }\n          }\n        });\n        if (authors.length > 0) {\n          // If we got multiple elements, join them\n          // If we got one element that looks like a comma-separated list, return as-is\n          const result = authors.join(', ');\n          if (result.length > 2) {\n            return result;\n          }\n        }\n      }\n    }\n\n    return '';\n  }\n  \n  /**\n   * Extract description/abstract from document with DOM fallbacks\n   */\n  protected extractDescription(): string {\n    // Try meta tags first\n    const metaDescription = (\n      this.getMetaContent('meta[name=\"DC.Description\"]') || this.getMetaContent('meta[name=\"dc.description\"]') ||\n      this.getMetaContent('meta[name=\"citation_abstract\"]') ||\n      this.getMetaContent('meta[property=\"og:description\"]') ||\n      this.getMetaContent('meta[name=\"description\"]')\n    );\n\n    if (metaDescription && metaDescription.length > 50) {\n      return metaDescription;\n    }\n\n    // DOM-based fallback extraction for abstracts\n    const abstractSelectors = [\n      // Common academic patterns\n      '.abstract', '#abstract', '[id*=\"abstract\"]', '[class*=\"abstract\"]',\n      '.Abstract', '#Abstract',\n      // Specific patterns\n      '.abstractSection', '.abstract-content', '.abstract-text',\n      '.paper-abstract', '.article-abstract',\n      // arXiv patterns\n      'blockquote.abstract',\n      // Summary patterns (some sites use \"summary\" instead of \"abstract\")\n      '.summary', '#summary', '.article-summary',\n      // IEEE/ACM patterns\n      '.abstract-text', '.abstractInFull',\n      // Nature/Science patterns\n      '.c-article-section__content', '[data-component=\"article-abstract\"]',\n      // Schema.org patterns\n      '[itemprop=\"description\"]', '[itemprop=\"abstract\"]'\n    ];\n\n    for (const selector of abstractSelectors) {\n      const element = this.document.querySelector(selector);\n      if (element) {\n        let text = element.textContent?.trim() || '';\n        // Clean up the abstract\n        text = text\n          .replace(/^(abstract:?|summary:?)\\s*/i, '')\n          .replace(/\\s+/g, ' ')\n          .trim();\n        // Only use if it looks like a real abstract (not too short)\n        if (text.length > 100) {\n          return text;\n        }\n      }\n    }\n\n    // If we have a short meta description, return it as fallback\n    if (metaDescription) {\n      return metaDescription;\n    }\n\n    return '';\n  }\n  \n  /**\n   * Extract publication date from document with DOM fallbacks\n   */\n  protected extractPublishedDate(): string {\n    // Try meta tags first\n    const metaDate = (\n      this.getMetaContent('meta[name=\"DC.Date.issued\"]') || this.getMetaContent('meta[name=\"dc.date.issued\"]') ||\n      this.getMetaContent('meta[name=\"dc.date\"]') || this.getMetaContent('meta[name=\"dc.Date\"]') ||\n      this.getMetaContent('meta[name=\"DC.Date\"]') ||\n      this.getMetaContent('meta[name=\"citation_date\"]') ||\n      this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n      this.getMetaContent('meta[name=\"citation_online_date\"]') ||\n      this.getMetaContent('meta[property=\"article:published_time\"]') ||\n      this.getMetaContent('meta[property=\"article:modified_time\"]')\n    );\n\n    if (metaDate) {\n      return metaDate;\n    }\n\n    // DOM-based fallback extraction\n    const dateSelectors = [\n      // Common patterns\n      '.date', '.pub-date', '.publication-date', '.published-date',\n      '.article-date', '.paper-date', '.dateline',\n      '[itemprop=\"datePublished\"]', '[itemprop=\"dateCreated\"]',\n      'time[datetime]', 'time[pubdate]',\n      // arXiv patterns\n      '.dateline', '.submission-history',\n      // Specific patterns\n      '.meta-date', '.entry-date', '.post-date'\n    ];\n\n    for (const selector of dateSelectors) {\n      const element = this.document.querySelector(selector);\n      if (element) {\n        // Check for datetime attribute first (more reliable)\n        const datetime = element.getAttribute('datetime') || element.getAttribute('content');\n        if (datetime) {\n          return datetime;\n        }\n        // Fall back to text content\n        const text = element.textContent?.trim();\n        if (text && this.looksLikeDate(text)) {\n          return text;\n        }\n      }\n    }\n\n    return '';\n  }\n\n  /**\n   * Check if a string looks like a date\n   */\n  protected looksLikeDate(text: string): boolean {\n    // Common date patterns\n    const datePatterns = [\n      /\\d{4}-\\d{2}-\\d{2}/, // ISO format\n      /\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}/, // US format\n      /\\d{1,2}\\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/i, // Month name\n      /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s+\\d{1,2}/i, // Month name\n      /(January|February|March|April|May|June|July|August|September|October|November|December)/i,\n      /\\d{4}/ // Just a year\n    ];\n    return datePatterns.some(pattern => pattern.test(text));\n  }\n  \n  /**\n   * Extract DOI (Digital Object Identifier) from document with URL and DOM fallbacks\n   */\n  protected extractDoi(): string {\n    // Try meta tags first\n    const metaDoi = (\n      this.getMetaContent('meta[name=\"DC.Identifier.DOI\"]') || this.getMetaContent('meta[name=\"dc.identifier.doi\"]') ||\n      this.getMetaContent('meta[name=\"citation_doi\"]') ||\n      this.getMetaContent('meta[name=\"DOI\"]') || this.getMetaContent('meta[name=\"doi\"]')\n    );\n\n    if (metaDoi) {\n      return metaDoi;\n    }\n\n    // Try to extract DOI from URL\n    const doiFromUrl = this.extractDoiFromUrl(this.url);\n    if (doiFromUrl) {\n      return doiFromUrl;\n    }\n\n    // DOM-based fallback - look for DOI links or text\n    const doiSelectors = [\n      'a[href*=\"doi.org/10.\"]',\n      'a[href*=\"/doi/10.\"]',\n      '.doi', '#doi', '[class*=\"doi\"]'\n    ];\n\n    for (const selector of doiSelectors) {\n      const element = this.document.querySelector(selector);\n      if (element) {\n        // Check href for DOI\n        const href = element.getAttribute('href');\n        if (href) {\n          const doi = this.extractDoiFromUrl(href);\n          if (doi) return doi;\n        }\n        // Check text content\n        const text = element.textContent?.trim();\n        if (text) {\n          const doiMatch = text.match(/10\\.\\d{4,}\\/[^\\s]+/);\n          if (doiMatch) {\n            return doiMatch[0];\n          }\n        }\n      }\n    }\n\n    return '';\n  }\n\n  /**\n   * Extract DOI from a URL\n   */\n  protected extractDoiFromUrl(url: string): string {\n    // Common DOI URL patterns\n    const doiPatterns = [\n      /doi\\.org\\/(10\\.\\d{4,}\\/[^\\s?#]+)/i,\n      /\\/doi\\/(?:abs|full|pdf|epdf)?\\/?((10\\.\\d{4,}\\/[^\\s?#]+))/i,\n      /doi[=:](10\\.\\d{4,}\\/[^\\s&?#]+)/i\n    ];\n\n    for (const pattern of doiPatterns) {\n      const match = url.match(pattern);\n      if (match) {\n        return match[1] || match[2];\n      }\n    }\n\n    return '';\n  }\n  \n  /**\n   * Extract journal name from document\n   */\n  protected extractJournalName(): string {\n    return (\n      this.getMetaContent('meta[name=\"DC.Source\"]') || this.getMetaContent('meta[name=\"dc.source\"]') ||\n      this.getMetaContent('meta[name=\"citation_journal_title\"]')\n    );\n  }\n  \n  /**\n   * Extract keywords/tags from document\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"keywords\"]') ||\n                    this.getMetaContent('meta[name=\"DC.Subject\"]') || this.getMetaContent('meta[name=\"dc.subject\"]');\n    \n    if (keywords) {\n      return keywords.split(',').map(tag => tag.trim());\n    }\n    \n    return [];\n  }\n  \n  /**\n   * Determine if the current URL is a PDF\n   */\n  public isPdf(): boolean {\n    return isPdfUrl(this.url);\n  }\n  \n  /**\n   * Get the source type (PDF or URL)\n   */\n  public getSourceType(): SourceType {\n    return this.isPdf() ? SOURCE_TYPES.PDF : SOURCE_TYPES.URL;\n  }\n  \n  /**\n   * Generate a paper ID for the current URL\n   */\n  public generatePaperId(): string {\n    return generatePaperIdFromUrl(this.url);\n  }\n}\n\n/**\n * Create a common metadata extractor for a document\n * Factory function for creating the default extractor\n */\nexport function createMetadataExtractor(document: Document): MetadataExtractor {\n  return new MetadataExtractor(document);\n}\n\n/**\n * Extract common metadata from a document\n * Convenience function for quick extraction\n */\nexport function extractCommonMetadata(document: Document): ExtractedMetadata {\n  return createMetadataExtractor(document).extract();\n}\n\n/**\n * Generate a paper ID from a URL\n * Creates a consistent hash-based identifier\n */\nexport function generatePaperIdFromUrl(url: string): string {\n  // Use a basic hash function to create an ID from the URL\n  let hash = 0;\n  for (let i = 0; i < url.length; i++) {\n    const char = url.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  \n  // Create a positive hexadecimal string\n  const positiveHash = Math.abs(hash).toString(16).toUpperCase();\n  \n  // Use the first 8 characters as the ID\n  return positiveHash.substring(0, 8);\n}\n\n/**\n * Determine if a URL is a PDF\n */\nexport function isPdfUrl(url: string): boolean {\n  return url.toLowerCase().endsWith('.pdf');\n}\n","// extension/source-integration/base-source.ts\n// Base class for source integrations with default identifier formatting\n// and metadata extraction capability\n\nimport { SourceIntegration } from './types';\nimport { PaperMetadata } from '../papers/types';\nimport { loguru } from '../utils/logger';\nimport { \n  MetadataExtractor, \n  createMetadataExtractor,\n  generatePaperIdFromUrl\n} from './metadata-extractor';\n\nconst logger = loguru.getLogger('base-source');\n\n/**\n * Base class for source integrations\n * Provides default implementations for all methods\n * Specific sources can override as needed\n */\nexport class BaseSourceIntegration implements SourceIntegration {\n  // Default properties - set for generic web pages\n  readonly id: string = 'url';\n  readonly name: string = 'Web Page';\n  readonly urlPatterns: RegExp[] = [\n    /^https?:\\/\\/(?!.*\\.pdf($|\\?|#)).*$/i  // Match HTTP/HTTPS URLs that aren't PDFs\n  ];\n  readonly contentScriptMatches: string[] = [];\n\n  /**\n   * Check if this integration can handle the given URL\n   * Default implementation checks against urlPatterns\n   */\n  canHandleUrl(url: string): boolean {\n    return this.urlPatterns.some(pattern => pattern.test(url));\n  }\n\n  /**\n   * Extract paper ID from URL\n   * Default implementation creates a hash from the URL\n   */\n  extractPaperId(url: string): string | null {\n    return generatePaperIdFromUrl(url);\n  }\n  \n  /**\n   * Create a metadata extractor for the given document\n   * Override this method to provide a custom extractor for your source\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return createMetadataExtractor(document);\n  }\n  \n  /**\n   * Extract metadata from a page\n   * Default implementation uses common metadata extraction\n   */\n  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {\n    try {\n      logger.debug(`Extracting metadata using base extractor for ID: ${paperId}`);\n      \n      // Create a metadata extractor for this document\n      const extractor = this.createMetadataExtractor(document);\n      \n      // Extract metadata\n      const extracted = extractor.extract();\n      const url = document.location.href;\n      \n      // Determine source type (PDF or URL)\n      const sourceType = extractor.getSourceType();\n      \n      // Create PaperMetadata object\n      return {\n        sourceId: this.id,\n        //paperId: this.formatPaperId(paperId),\n        paperId: paperId,\n        url: url,\n        title: extracted.title || document.title || paperId,\n        authors: extracted.authors || '',\n        abstract: extracted.description || '',\n        timestamp: new Date().toISOString(),\n        rating: 'novote',\n        publishedDate: extracted.publishedDate || '',\n        tags: extracted.tags || [],\n        doi: extracted.doi,\n        journalName: extracted.journalName,\n        sourceType: sourceType // Store the source type for reference\n      };\n    } catch (error) {\n      logger.error('Error extracting metadata with base extractor', error);\n      return null;\n    }\n  }\n  \n  /**\n   * Format a paper identifier for this source\n   * Default implementation uses the format: sourceId.paperId\n   */\n  formatPaperId(paperId: string): string {\n    return `${this.id}.${paperId}`;\n  }\n  \n  /**\n   * Parse a paper identifier specific to this source\n   * Default implementation handles source.paperId format and extracts paperId\n   */\n  parsePaperId(identifier: string): string | null {\n    const prefix = `${this.id}.`;\n    \n    if (identifier.startsWith(prefix)) {\n      return identifier.substring(prefix.length);\n    }\n    \n    // Try legacy format (sourceId:paperId)\n    const legacyPrefix = `${this.id}:`;\n    if (identifier.startsWith(legacyPrefix)) {\n      logger.debug(`Parsed legacy format identifier: ${identifier}`);\n      return identifier.substring(legacyPrefix.length);\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Format a storage object ID for this source\n   * Default implementation uses the format: type:sourceId.paperId\n   */\n  formatObjectId(type: string, paperId: string): string {\n    return `${type}:${this.formatPaperId(paperId)}`;\n  }\n}\n","// extension/source-integration/arxiv/index.ts\n// ArXiv integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { PaperMetadata } from '../../papers/types';\nimport { MetadataExtractor, ExtractedMetadata } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('arxiv-integration');\n\n/**\n * Custom metadata extractor for arXiv pages\n */\nclass ArxivMetadataExtractor extends MetadataExtractor {\n  private apiMetadata?: Partial<ExtractedMetadata>;\n  \n  constructor(document: Document, apiMetadata?: Partial<ExtractedMetadata>) {\n    super(document);\n    this.apiMetadata = apiMetadata;\n  }\n  \n  /**\n   * Override title extraction to use API data if available\n   */\n  protected extractTitle(): string {\n    if (this.apiMetadata?.title) {\n      return this.apiMetadata.title;\n    }\n    \n    return super.extractTitle();\n  }\n  \n  /**\n   * Override authors extraction to use API data if available\n   */\n  protected extractAuthors(): string {\n    if (this.apiMetadata?.authors) {\n      return this.apiMetadata.authors;\n    }\n    \n    // arXiv-specific selectors\n    const authorLinks = this.document.querySelectorAll('.authors a');\n    if (authorLinks.length > 0) {\n      return Array.from(authorLinks)\n        .map(link => link.textContent?.trim())\n        .filter(Boolean)\n        .join(', ');\n    }\n    \n    return super.extractAuthors();\n  }\n  \n  /**\n   * Override description extraction to use API data if available\n   */\n  protected extractDescription(): string {\n    if (this.apiMetadata?.description) {\n      return this.apiMetadata.description;\n    }\n    \n    // arXiv-specific selectors\n    const abstract = this.document.querySelector('.abstract')?.textContent?.trim();\n    if (abstract) {\n      // Remove \"Abstract:\" prefix if present\n      return abstract.replace(/^Abstract:\\s*/i, '');\n    }\n    \n    return super.extractDescription();\n  }\n  \n  /**\n   * Override published date extraction to use API data if available\n   */\n  protected extractPublishedDate(): string {\n    if (this.apiMetadata?.publishedDate) {\n      return this.apiMetadata.publishedDate;\n    }\n    \n    // arXiv-specific date extraction\n    const datelineElement = this.document.querySelector('.dateline');\n    if (datelineElement) {\n      const dateText = datelineElement.textContent;\n      const dateMatch = dateText?.match(/\\(Submitted on ([^)]+)\\)/);\n      if (dateMatch) {\n        return dateMatch[1];\n      }\n    }\n    \n    return super.extractPublishedDate();\n  }\n  \n  /**\n   * Override DOI extraction to use API data if available\n   */\n  protected extractDoi(): string {\n    return this.apiMetadata?.doi || super.extractDoi();\n  }\n  \n  /**\n   * Override journal extraction to use API data if available\n   */\n  protected extractJournalName(): string {\n    return this.apiMetadata?.journalName || super.extractJournalName();\n  }\n  \n  /**\n   * Override tags extraction to use API data if available\n   */\n  protected extractTags(): string[] {\n    if (this.apiMetadata?.tags) {\n      return this.apiMetadata.tags;\n    }\n    \n    // arXiv-specific category extraction\n    const subjects = this.document.querySelector('.subjects')?.textContent?.trim();\n    if (subjects) {\n      return subjects.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n    \n    return super.extractTags();\n  }\n}\n\n/**\n * ArXiv integration with custom metadata extraction\n */\nexport class ArXivIntegration extends BaseSourceIntegration {\n  readonly id = 'arxiv';\n  readonly name = 'arXiv.org';\n  \n  // URL patterns for papers\n  readonly urlPatterns = [\n    /arxiv\\.org\\/(abs|pdf|html)\\/([0-9.]+)/,\n    /arxiv\\.org\\/\\w+\\/([0-9.]+)/\n  ];\n  \n  // Content script matches\n  // readonly contentScriptMatches = [\n  //   \"*://*.arxiv.org/*\"\n  // ];\n\n  // ArXiv API endpoint\n  private readonly API_BASE_URL = 'https://export.arxiv.org/api/query';\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    for (const pattern of this.urlPatterns) {\n      const match = url.match(pattern);\n      if (match) {\n        return match[2] || match[1]; // The capture group with the paper ID\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Create a custom metadata extractor for arXiv\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new ArxivMetadataExtractor(document);\n  }\n\n  /**\n   * Fetch metadata from ArXiv API\n   */\n  private async fetchFromApi(paperId: string): Promise<Partial<ExtractedMetadata> | null> {\n    try {\n      const apiUrl = `${this.API_BASE_URL}?id_list=${paperId}`;\n      logger.debug(`Fetching from ArXiv API: ${apiUrl}`);\n      \n      const response = await fetch(apiUrl);\n      if (!response.ok) {\n        logger.error(`ArXiv API request failed with status: ${response.status}`);\n        return null;\n      }\n      \n      const xmlText = await response.text();\n      \n      // Parse XML to JSON\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(xmlText, 'text/xml');\n      \n      // Convert XML to a more manageable format\n      const entry = xmlDoc.querySelector('entry');\n      if (!entry) {\n        logger.warn('No entry found in ArXiv API response');\n        return null;\n      }\n      \n      // Extract metadata from XML\n      const title = entry.querySelector('title')?.textContent?.trim() || '';\n      const summary = entry.querySelector('summary')?.textContent?.trim() || '';\n      const published = entry.querySelector('published')?.textContent?.trim() || '';\n      \n      // Extract authors\n      const authorElements = entry.querySelectorAll('author name');\n      const authors = Array.from(authorElements)\n        .map(el => el.textContent?.trim())\n        .filter(Boolean)\n        .join(', ');\n      \n      // Extract DOI if available\n      const doi = entry.querySelector('arxiv\\\\:doi, doi')?.textContent?.trim();\n      \n      // Extract journal reference if available\n      const journalRef = entry.querySelector('arxiv\\\\:journal_ref, journal_ref')?.textContent?.trim();\n      \n      // Extract categories\n      const categoryElements = entry.querySelectorAll('category');\n      const categories = Array.from(categoryElements)\n        .map(el => el.getAttribute('term'))\n        .filter(Boolean) as string[];\n      \n      return {\n        title,\n        authors,\n        description: summary,\n        publishedDate: published,\n        doi,\n        journalName: journalRef,\n        tags: categories\n      };\n      \n    } catch (error) {\n      logger.error('Error fetching from ArXiv API', error);\n      return null;\n    }\n  }\n\n  /**\n   * Extract metadata from page or fetch from API\n   * Override parent method to handle the API fallback\n   */\n  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {\n    try {\n      logger.info(`Extracting metadata for arXiv ID: ${paperId}`);\n      \n      // Try to extract from page first\n      const extractor = this.createMetadataExtractor(document);\n      const pageMetadata = extractor.extract();\n      \n      // Check if we have the essential fields\n      const hasTitle = pageMetadata.title && pageMetadata.title !== document.title;\n      const hasAuthors = pageMetadata.authors && pageMetadata.authors.length > 0;\n      const hasAbstract = pageMetadata.description && pageMetadata.description.length > 0;\n      \n      if (hasTitle && hasAuthors && hasAbstract) {\n        logger.debug('Successfully extracted complete metadata from page');\n        return this.convertToPageMetadata(pageMetadata, paperId, extractor.getSourceType());\n      }\n      \n      // If page extraction is incomplete, fetch from API\n      logger.info('Page metadata incomplete, fetching from ArXiv API');\n      const apiMetadata = await this.fetchFromApi(paperId);\n      \n      if (!apiMetadata) {\n        logger.warn('Failed to fetch metadata from ArXiv API, using partial page data');\n        return this.convertToPageMetadata(pageMetadata, paperId, extractor.getSourceType());\n      }\n      \n      // Create a new extractor with API data\n      const enhancedExtractor = new ArxivMetadataExtractor(document, apiMetadata);\n      const mergedMetadata = enhancedExtractor.extract();\n      \n      logger.debug('Merged metadata from page and API', mergedMetadata);\n      return this.convertToPageMetadata(mergedMetadata, paperId, enhancedExtractor.getSourceType());\n      \n    } catch (error) {\n      logger.error('Error extracting metadata for arXiv', error);\n      return null;\n    }\n  }\n\n  /**\n   * Convert ExtractedMetadata to PaperMetadata\n   */\n  private convertToPageMetadata(extracted: ExtractedMetadata, paperId: string, sourceType: string): PaperMetadata {\n    return {\n      sourceId: this.id,\n      paperId: paperId,\n      url: extracted.url || '',\n      title: extracted.title,\n      authors: extracted.authors,\n      abstract: extracted.description,\n      timestamp: new Date().toISOString(),\n      rating: 'novote',\n      publishedDate: extracted.publishedDate,\n      tags: extracted.tags || [],\n      doi: extracted.doi,\n      journalName: extracted.journalName,\n      sourceType: sourceType\n    };\n  }\n}\n\n// Export a singleton instance that can be used by both background and content scripts\nexport const arxivIntegration = new ArXivIntegration();\n","// extension/source-integration/openreview/index.ts\n// OpenReview integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { PaperMetadata } from '../../papers/types';\nimport { MetadataExtractor, createMetadataExtractor, ExtractedMetadata } from '..//metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('openreview-integration');\n\n/**\n * Custom metadata extractor for OpenReview pages\n */\nclass OpenReviewMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract metadata from OpenReview pages\n   */\n  public extract(): ExtractedMetadata {\n    // First try to extract using standard methods\n    const baseMetadata = super.extract();\n    \n    try {\n      // Get title from OpenReview-specific elements\n      const title = this.document.querySelector('.citation_title')?.textContent || \n                   this.document.querySelector('.forum-title h2')?.textContent;\n      \n      // Get authors\n      const authorElements = Array.from(this.document.querySelectorAll('.forum-authors a'));\n      const authors = authorElements\n        .map(el => el.textContent)\n        .filter(Boolean)\n        .join(', ');\n      \n      // Get abstract\n      const abstract = this.document.querySelector('meta[name=\"citation_abstract\"]')?.getAttribute('content') ||\n                     Array.from(this.document.querySelectorAll('.note-content-field'))\n                       .find(el => el.textContent?.includes('Abstract'))\n                       ?.nextElementSibling?.textContent;\n      \n      // Get publication date\n      const dateText = this.document.querySelector('.date.item')?.textContent;\n      let publishedDate = '';\n      if (dateText) {\n        const dateMatch = dateText.match(/Published: ([^,]+)/);\n        if (dateMatch) {\n          publishedDate = dateMatch[1];\n        }\n      }\n      \n      // Get DOI if available\n      const doi = this.document.querySelector('meta[name=\"citation_doi\"]')?.getAttribute('content') || '';\n      \n      // Get conference/journal name\n      const venueElements = this.document.querySelectorAll('.forum-meta .item');\n      let venue = '';\n      for (let i = 0; i < venueElements.length; i++) {\n        const el = venueElements[i];\n        if (el.querySelector('.glyphicon-folder-open')) {\n          venue = el.textContent?.trim() || '';\n          break;\n        }\n      }\n      \n      // Get tags/keywords\n      const keywordsElement = Array.from(this.document.querySelectorAll('.note-content-field'))\n        .find(el => el.textContent?.includes('Keywords'));\n      let tags: string[] = [];\n      if (keywordsElement) {\n        const keywordsValue = keywordsElement.nextElementSibling?.textContent;\n        if (keywordsValue) {\n          tags = keywordsValue.split(',').map(tag => tag.trim());\n        }\n      }\n      \n      return {\n        title: title || baseMetadata.title,\n        authors: authors || baseMetadata.authors,\n        description: abstract || baseMetadata.description,\n        publishedDate: publishedDate || baseMetadata.publishedDate,\n        doi: doi || baseMetadata.doi,\n        journalName: venue || baseMetadata.journalName,\n        tags: tags.length ? tags : baseMetadata.tags,\n        url: this.url\n      };\n    } catch (error) {\n      logger.error('Error during OpenReview-specific extraction', error);\n      return baseMetadata;\n    }\n  }\n}\n\n/**\n * OpenReview integration with custom metadata extraction\n */\nexport class OpenReviewIntegration extends BaseSourceIntegration {\n  readonly id = 'openreview';\n  readonly name = 'OpenReview';\n  \n  // URL patterns for papers (various OpenReview formats)\n  readonly urlPatterns = [\n    // Forum page (main paper page)\n    /openreview\\.net\\/forum\\?id=([a-zA-Z0-9_-]+)/,\n    // PDF page\n    /openreview\\.net\\/pdf\\?id=([a-zA-Z0-9_-]+)/,\n    // Attachment URLs\n    /openreview\\.net\\/attachment\\?id=([a-zA-Z0-9_-]+)/,\n    // References/revisions\n    /openreview\\.net\\/references\\?referent=([a-zA-Z0-9_-]+)/,\n    /openreview\\.net\\/revisions\\?id=([a-zA-Z0-9_-]+)/,\n    // Group/venue pages (for browsing)\n    /openreview\\.net\\/group\\?id=([^&\\s]+)/,\n    // Generic OpenReview paper URL\n    /openreview\\.net\\/(?:forum|pdf)\\?id=/,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /openreview\\.net\\/(forum|pdf|attachment|references|revisions)\\?id=/.test(url);\n  }\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try to extract ID from various URL formats\n    const idMatch = url.match(/[?&]id=([a-zA-Z0-9_-]+)/);\n    if (idMatch) {\n      return idMatch[1];\n    }\n\n    // Try referent parameter\n    const referentMatch = url.match(/[?&]referent=([a-zA-Z0-9_-]+)/);\n    if (referentMatch) {\n      return referentMatch[1];\n    }\n\n    return null;\n  }\n\n  /**\n   * Create a custom metadata extractor for OpenReview\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new OpenReviewMetadataExtractor(document);\n  }\n\n  /**\n   * Extract metadata from page\n   * Override parent method to handle OpenReview-specific extraction\n   */\n  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {\n    logger.info(`Extracting metadata for OpenReview ID: ${paperId}`);\n    \n    // Extract metadata using our custom extractor\n    const metadata = await super.extractMetadata(document, paperId);\n    \n    if (metadata) {\n      // Add any OpenReview-specific metadata processing here\n      logger.debug('Extracted metadata from OpenReview page');\n      \n      // Check if we're on a PDF page and adjust metadata accordingly\n      if (document.location.href.includes('/pdf?id=')) {\n        metadata.sourceType = 'pdf';\n      }\n    }\n    \n    return metadata;\n  }\n}\n\n// Export a singleton instance that can be used by both background and content scripts\nexport const openReviewIntegration = new OpenReviewIntegration();\n","// extension/source-integration/nature/index.ts\n// Nature.com integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { PaperMetadata } from '../../papers/types';\nimport { MetadataExtractor, ExtractedMetadata } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('nature-integration');\n\n/**\n * Custom metadata extractor for Nature.com pages\n */\nclass NatureMetadataExtractor extends MetadataExtractor {\n  /**\n   * Override title extraction to use meta tag first\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') || \n                      this.getMetaContent('meta[property=\"og:title\"]');\n    return metaTitle || super.extractTitle();\n  }\n  \n  /**\n   * Override authors extraction to use meta tag first\n   */\n  protected extractAuthors(): string {\n    const metaAuthors = this.getMetaContent('meta[name=\"citation_author\"]');\n    if (metaAuthors) {\n      return metaAuthors;\n    }\n    // Fallback to HTML extraction\n    const authorElements = this.document.querySelectorAll('.c-article-author-list__item');\n    if (authorElements.length > 0) {\n      return Array.from(authorElements)\n        .map(el => el.textContent?.trim())\n        .filter(Boolean)\n        .join(', ');\n    }\n    return super.extractAuthors();\n  }\n  \n  /**\n   * Extract keywords/tags from document\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"dc.subject\"]');\n    \n    if (keywords) {\n      return keywords.split(',').map(tag => tag.trim());\n    }\n    \n    return [];\n  }\n  \n\n  /**\n   * Override description extraction to use meta tag first\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Override published date extraction to use meta tag\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') || super.extractPublishedDate();\n  }\n\n  /**\n   * Override DOI extraction to use meta tag\n   */\n  protected extractDoi(): string {\n    return this.getMetaContent('meta[name=\"citation_doi\"]') || super.extractDoi();\n  }\n}\n\n/**\n * Nature.com integration with custom metadata extraction\n */\nexport class NatureIntegration extends BaseSourceIntegration {\n  readonly id = 'nature';\n  readonly name = 'Nature'; \n\n  // URL patterns for Nature articles (including all Nature journals)\n  readonly urlPatterns = [\n    // Main nature.com articles\n    /nature\\.com\\/articles\\/([^?#/]+)/,\n    // Nature sub-journals (e.g., nature.com/ncomms/articles/...)\n    /nature\\.com\\/\\w+\\/articles\\/([^?#/]+)/,\n    // Scientific Reports\n    /nature\\.com\\/srep\\/articles\\/([^?#/]+)/,\n    // Nature Communications\n    /nature\\.com\\/ncomms\\/articles\\/([^?#/]+)/,\n    // Nature Methods, Nature Reviews, etc.\n    /nature\\.com\\/n[a-z]+\\/articles\\/([^?#/]+)/,\n    // DOI-based URLs\n    /nature\\.com\\/doi\\/(10\\.\\d+\\/[^?#\\s]+)/,\n    // Full text and PDF variants\n    /nature\\.com\\/articles\\/([^?#/]+)\\.pdf/,\n    /nature\\.com\\/articles\\/([^?#/]+)\\/full/,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /nature\\.com\\/(articles|doi)\\//.test(url) ||\n           /nature\\.com\\/\\w+\\/articles\\//.test(url);\n  }\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try to extract article ID\n    const articleMatch = url.match(/nature\\.com\\/(?:\\w+\\/)?articles\\/([^?#/]+)/);\n    if (articleMatch) {\n      return articleMatch[1].replace(/\\.pdf$/, '');\n    }\n\n    // Try DOI format\n    const doiMatch = url.match(/nature\\.com\\/doi\\/(10\\.\\d+\\/[^?#\\s]+)/);\n    if (doiMatch) {\n      return doiMatch[1];\n    }\n\n    return null;\n  }\n\n  /**\n   * Create a custom metadata extractor for Nature.com\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new NatureMetadataExtractor(document);\n  }\n}\n\n// Export a singleton instance \nexport const natureIntegration = new NatureIntegration();\n","// extension/source-integration/pnas/index.ts\nimport { BaseSourceIntegration } from '../base-source';\n\nexport class PnasIntegration extends BaseSourceIntegration {\n  readonly id = 'pnas';\n  readonly name = 'PNAS';\n\n  // URL patterns for PNAS articles\n  readonly urlPatterns = [\n    // DOI-based URLs (most common)\n    /pnas\\.org\\/doi\\/(10\\.1073\\/pnas\\.[0-9]+)/,\n    /pnas\\.org\\/doi\\/abs\\/(10\\.1073\\/pnas\\.[0-9]+)/,\n    /pnas\\.org\\/doi\\/full\\/(10\\.1073\\/pnas\\.[0-9]+)/,\n    /pnas\\.org\\/doi\\/pdf\\/(10\\.1073\\/pnas\\.[0-9]+)/,\n    /pnas\\.org\\/doi\\/epdf\\/(10\\.1073\\/pnas\\.[0-9]+)/,\n    // Alternate DOI formats\n    /pnas\\.org\\/doi\\/(10\\.1073\\/[^\\s?#]+)/,\n    // Content-based URLs (older format)\n    /pnas\\.org\\/content\\/(\\d+\\/\\d+\\/[^\\s?#]+)/,\n    /pnas\\.org\\/content\\/early\\/\\d+\\/\\d+\\/\\d+\\/(\\d+)/,\n    // Legacy cgi format\n    /pnas\\.org\\/cgi\\/doi\\/(10\\.1073\\/[^\\s?#]+)/,\n    // Generic PNAS DOI pattern\n    /pnas\\.org\\/doi\\//,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /pnas\\.org\\/(doi|content|cgi)\\//.test(url);\n  }\n\n  /**\n   * Extract paper ID (DOI) from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try DOI format\n    const doiMatch = url.match(/pnas\\.org\\/(?:doi\\/(?:abs|full|pdf|epdf)?\\/?)?(10\\.1073\\/[^\\s?#]+)/);\n    if (doiMatch) {\n      return doiMatch[1];\n    }\n\n    // Try content-based format\n    const contentMatch = url.match(/content\\/(\\d+\\/\\d+\\/[^\\s?#.]+)/);\n    if (contentMatch) {\n      return contentMatch[1];\n    }\n\n    // Try early format\n    const earlyMatch = url.match(/early\\/\\d+\\/\\d+\\/\\d+\\/(\\d+)/);\n    if (earlyMatch) {\n      return earlyMatch[1];\n    }\n\n    return null;\n  }\n}\n\nexport const pnasIntegration = new PnasIntegration();\n","// extension/source-integration/sciencedirect/index.ts\n// ScienceDirect integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { MetadataExtractor } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('sciencedirect-integration');\n\n/**\n * Custom metadata extractor for ScienceDirect pages\n */\nclass ScienceDirectMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract title using citation meta tags\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') ||\n                      this.getMetaContent('meta[property=\"og:title\"]');\n    return metaTitle || super.extractTitle();\n  }\n\n  /**\n   * Extract authors from citation meta tags\n   */\n  protected extractAuthors(): string {\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    }\n\n    return super.extractAuthors();\n  }\n\n  /**\n   * Extract abstract/description\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Extract publication date\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_online_date\"]') ||\n           super.extractPublishedDate();\n  }\n\n  /**\n   * Extract DOI\n   */\n  protected extractDoi(): string {\n    return this.getMetaContent('meta[name=\"citation_doi\"]') || super.extractDoi();\n  }\n\n  /**\n   * Extract journal name\n   */\n  protected extractJournalName(): string {\n    return this.getMetaContent('meta[name=\"citation_journal_title\"]') || super.extractJournalName();\n  }\n\n  /**\n   * Extract keywords/tags\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"citation_keywords\"]') ||\n                    this.getMetaContent('meta[name=\"keywords\"]');\n\n    if (keywords) {\n      return keywords.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n\n    return super.extractTags();\n  }\n}\n\n/**\n * ScienceDirect integration for Elsevier journals\n */\nexport class ScienceDirectIntegration extends BaseSourceIntegration {\n  readonly id = 'sciencedirect';\n  readonly name = 'ScienceDirect';\n\n  // URL patterns for ScienceDirect articles\n  readonly urlPatterns = [\n    // PII-based URLs (most common)\n    /sciencedirect\\.com\\/science\\/article\\/pii\\/([A-Z0-9]+)/i,\n    /sciencedirect\\.com\\/science\\/article\\/abs\\/pii\\/([A-Z0-9]+)/i,\n    // Book chapters\n    /sciencedirect\\.com\\/science\\/book\\/([A-Z0-9]+)/i,\n    // DOI-based URLs\n    /sciencedirect\\.com\\/science\\/article\\/doi\\/(10\\.\\d+\\/[^\\s?#]+)/i,\n    // Generic article URLs\n    /sciencedirect\\.com\\/science\\/article\\//,\n    // PDF direct links\n    /sciencedirect\\.com\\/\\S+\\.pdf/i,\n    // Reader view\n    /reader\\.elsevier\\.com\\/reader\\/sd\\/pii\\/([A-Z0-9]+)/i,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /sciencedirect\\.com\\/science\\/article\\//.test(url) ||\n           /sciencedirect\\.com\\/science\\/book\\//.test(url) ||\n           /reader\\.elsevier\\.com\\/reader\\/sd\\/pii\\//.test(url);\n  }\n\n  /**\n   * Extract paper ID (PII) from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try PII format (most common)\n    const piiMatch = url.match(/pii\\/([A-Z0-9]+)/i);\n    if (piiMatch) {\n      return piiMatch[1];\n    }\n\n    // Try DOI format\n    const doiMatch = url.match(/doi\\/(10\\.\\d+\\/[^\\s?#]+)/i);\n    if (doiMatch) {\n      return doiMatch[1];\n    }\n\n    // Try book format\n    const bookMatch = url.match(/book\\/([A-Z0-9]+)/i);\n    if (bookMatch) {\n      return bookMatch[1];\n    }\n\n    return null;\n  }\n\n  /**\n   * Create custom metadata extractor for ScienceDirect\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new ScienceDirectMetadataExtractor(document);\n  }\n}\n\n// Export singleton instance\nexport const scienceDirectIntegration = new ScienceDirectIntegration();\n","// extension/source-integration/springer/index.ts\n// Springer integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { MetadataExtractor } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('springer-integration');\n\n/**\n * Custom metadata extractor for Springer pages\n */\nclass SpringerMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract title using citation meta tags\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') ||\n                      this.getMetaContent('meta[property=\"og:title\"]') ||\n                      this.getMetaContent('meta[name=\"dc.title\"]');\n    return metaTitle || super.extractTitle();\n  }\n\n  /**\n   * Extract authors from citation meta tags\n   */\n  protected extractAuthors(): string {\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    }\n\n    // Fallback to DC creator\n    const dcCreators: string[] = [];\n    this.document.querySelectorAll('meta[name=\"dc.creator\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) dcCreators.push(content);\n    });\n\n    if (dcCreators.length > 0) {\n      return dcCreators.join(', ');\n    }\n\n    return super.extractAuthors();\n  }\n\n  /**\n   * Extract abstract/description\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"dc.description\"]') ||\n                            this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Extract publication date\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_online_date\"]') ||\n           this.getMetaContent('meta[name=\"dc.date\"]') ||\n           super.extractPublishedDate();\n  }\n\n  /**\n   * Extract DOI\n   */\n  protected extractDoi(): string {\n    return this.getMetaContent('meta[name=\"citation_doi\"]') ||\n           this.getMetaContent('meta[name=\"dc.identifier\"]') ||\n           super.extractDoi();\n  }\n\n  /**\n   * Extract journal name\n   */\n  protected extractJournalName(): string {\n    return this.getMetaContent('meta[name=\"citation_journal_title\"]') ||\n           this.getMetaContent('meta[name=\"citation_conference_title\"]') ||\n           this.getMetaContent('meta[name=\"prism.publicationName\"]') ||\n           super.extractJournalName();\n  }\n\n  /**\n   * Extract keywords/tags\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"citation_keywords\"]') ||\n                    this.getMetaContent('meta[name=\"keywords\"]');\n\n    if (keywords) {\n      return keywords.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n\n    return super.extractTags();\n  }\n}\n\n/**\n * Springer integration for Springer Link articles\n */\nexport class SpringerIntegration extends BaseSourceIntegration {\n  readonly id = 'springer';\n  readonly name = 'Springer';\n\n  // URL patterns for Springer articles and chapters\n  readonly urlPatterns = [\n    // Articles with DOI\n    /link\\.springer\\.com\\/article\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // Book chapters with DOI\n    /link\\.springer\\.com\\/chapter\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // Books\n    /link\\.springer\\.com\\/book\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // Conference papers\n    /link\\.springer\\.com\\/content\\/pdf\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // Proceedings\n    /link\\.springer\\.com\\/proceeding\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // Reference work entries\n    /link\\.springer\\.com\\/referenceworkentry\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // PDF variants\n    /link\\.springer\\.com\\/content\\/pdf\\/(10\\.\\d+%2F[^\\s?#]+)/,\n    // EPUB variants\n    /link\\.springer\\.com\\/epub\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // Generic patterns for matching\n    /link\\.springer\\.com\\/article\\//,\n    /link\\.springer\\.com\\/chapter\\//,\n    /link\\.springer\\.com\\/book\\//,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /link\\.springer\\.com\\/(article|chapter|book|content|proceeding|referenceworkentry|epub)\\//.test(url);\n  }\n\n  /**\n   * Extract paper ID (DOI) from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try to extract DOI from URL path\n    const doiMatch = url.match(/link\\.springer\\.com\\/(?:article|chapter|book|content\\/pdf|proceeding|referenceworkentry|epub)\\/(10\\.\\d+[/%][^\\s?#]+)/);\n    if (doiMatch) {\n      // Decode URL-encoded DOIs\n      return decodeURIComponent(doiMatch[1]).replace(/%2F/gi, '/');\n    }\n\n    return null;\n  }\n\n  /**\n   * Create custom metadata extractor for Springer\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new SpringerMetadataExtractor(document);\n  }\n}\n\n// Export singleton instance\nexport const springerIntegration = new SpringerIntegration();\n","// extension/source-integration/ieee/index.ts\n// IEEE Xplore integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { MetadataExtractor } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('ieee-integration');\n\n/**\n * Custom metadata extractor for IEEE Xplore pages\n */\nclass IEEEMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract title using citation meta tags\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') ||\n                      this.getMetaContent('meta[property=\"og:title\"]');\n    return metaTitle || super.extractTitle();\n  }\n\n  /**\n   * Extract authors from citation meta tags\n   */\n  protected extractAuthors(): string {\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    }\n\n    // Fallback to HTML extraction\n    const authorElements = this.document.querySelectorAll('.authors-info .author span');\n    if (authorElements.length > 0) {\n      return Array.from(authorElements)\n        .map(el => el.textContent?.trim())\n        .filter(Boolean)\n        .join(', ');\n    }\n\n    return super.extractAuthors();\n  }\n\n  /**\n   * Extract abstract/description\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n\n    // IEEE often has abstract in a specific div\n    if (!metaDescription) {\n      const abstractDiv = this.document.querySelector('.abstract-text');\n      if (abstractDiv) {\n        return abstractDiv.textContent?.trim() || '';\n      }\n    }\n\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Extract publication date\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_online_date\"]') ||\n           super.extractPublishedDate();\n  }\n\n  /**\n   * Extract DOI\n   */\n  protected extractDoi(): string {\n    return this.getMetaContent('meta[name=\"citation_doi\"]') || super.extractDoi();\n  }\n\n  /**\n   * Extract journal/conference name\n   */\n  protected extractJournalName(): string {\n    return this.getMetaContent('meta[name=\"citation_journal_title\"]') ||\n           this.getMetaContent('meta[name=\"citation_conference_title\"]') ||\n           super.extractJournalName();\n  }\n\n  /**\n   * Extract keywords/tags\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"citation_keywords\"]') ||\n                    this.getMetaContent('meta[name=\"keywords\"]');\n\n    if (keywords) {\n      return keywords.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n\n    // IEEE-specific keyword extraction from HTML\n    const keywordElements = this.document.querySelectorAll('.keywords .keyword');\n    if (keywordElements.length > 0) {\n      return Array.from(keywordElements)\n        .map(el => el.textContent?.trim())\n        .filter(Boolean) as string[];\n    }\n\n    return super.extractTags();\n  }\n}\n\n/**\n * IEEE Xplore integration\n */\nexport class IEEEIntegration extends BaseSourceIntegration {\n  readonly id = 'ieee';\n  readonly name = 'IEEE Xplore';\n\n  // URL patterns for IEEE articles\n  readonly urlPatterns = [\n    // Standard document URLs\n    /ieeexplore\\.ieee\\.org\\/document\\/(\\d+)/,\n    /ieeexplore\\.ieee\\.org\\/abstract\\/document\\/(\\d+)/,\n    // Stamp (full text) URLs\n    /ieeexplore\\.ieee\\.org\\/stamp\\/stamp\\.jsp\\?.*arnumber=(\\d+)/,\n    // PDF direct links\n    /ieeexplore\\.ieee\\.org\\/ielx?\\d*\\/\\d+\\/\\d+\\/(\\d+)\\.pdf/,\n    // XPL URLs (older format)\n    /ieeexplore\\.ieee\\.org\\/xpl\\/articleDetails\\.jsp\\?arnumber=(\\d+)/,\n    /ieeexplore\\.ieee\\.org\\/xpl\\/tocresult\\.jsp/,\n    // Course/content URLs\n    /ieeexplore\\.ieee\\.org\\/courses\\/details\\/(\\d+)/,\n    // IEEE Computer Society\n    /computer\\.org\\/csdl\\/\\w+\\/\\d+\\/\\d+\\/(\\d+)/,\n    // Generic document pattern\n    /ieeexplore\\.ieee\\.org\\/document\\//,\n    /ieeexplore\\.ieee\\.org\\/abstract\\/document\\//,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /ieeexplore\\.ieee\\.org\\/(document|abstract|stamp|ielx?\\d*|xpl)\\//.test(url) ||\n           /computer\\.org\\/csdl\\//.test(url);\n  }\n\n  /**\n   * Extract paper ID (document number) from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try document/abstract URL\n    const docMatch = url.match(/document\\/(\\d+)/);\n    if (docMatch) {\n      return docMatch[1];\n    }\n\n    // Try arnumber parameter\n    const arnumberMatch = url.match(/arnumber=(\\d+)/);\n    if (arnumberMatch) {\n      return arnumberMatch[1];\n    }\n\n    // Try PDF URL format\n    const pdfMatch = url.match(/\\/(\\d+)\\.pdf/);\n    if (pdfMatch) {\n      return pdfMatch[1];\n    }\n\n    // Try IEEE Computer Society format\n    const csdlMatch = url.match(/csdl\\/\\w+\\/\\d+\\/\\d+\\/(\\d+)/);\n    if (csdlMatch) {\n      return csdlMatch[1];\n    }\n\n    return null;\n  }\n\n  /**\n   * Create custom metadata extractor for IEEE\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new IEEEMetadataExtractor(document);\n  }\n}\n\n// Export singleton instance\nexport const ieeeIntegration = new IEEEIntegration();\n","// extension/source-integration/acm/index.ts\n// ACM Digital Library integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { MetadataExtractor } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('acm-integration');\n\n/**\n * Custom metadata extractor for ACM DL pages\n */\nclass ACMMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract title using citation meta tags\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') ||\n                      this.getMetaContent('meta[property=\"og:title\"]') ||\n                      this.getMetaContent('meta[name=\"dc.Title\"]');\n    return metaTitle || super.extractTitle();\n  }\n\n  /**\n   * Extract authors from citation meta tags\n   */\n  protected extractAuthors(): string {\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    }\n\n    return super.extractAuthors();\n  }\n\n  /**\n   * Extract abstract/description\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Extract publication date\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_date\"]') ||\n           this.getMetaContent('meta[name=\"dc.Date\"]') ||\n           super.extractPublishedDate();\n  }\n\n  /**\n   * Extract DOI\n   */\n  protected extractDoi(): string {\n    return this.getMetaContent('meta[name=\"citation_doi\"]') ||\n           this.getMetaContent('meta[name=\"dc.Identifier\"]') ||\n           super.extractDoi();\n  }\n\n  /**\n   * Extract journal/conference name\n   */\n  protected extractJournalName(): string {\n    return this.getMetaContent('meta[name=\"citation_journal_title\"]') ||\n           this.getMetaContent('meta[name=\"citation_conference_title\"]') ||\n           this.getMetaContent('meta[name=\"dc.Source\"]') ||\n           super.extractJournalName();\n  }\n\n  /**\n   * Extract keywords/tags\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"citation_keywords\"]') ||\n                    this.getMetaContent('meta[name=\"keywords\"]');\n\n    if (keywords) {\n      return keywords.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n\n    return super.extractTags();\n  }\n}\n\n/**\n * ACM Digital Library integration\n */\nexport class ACMIntegration extends BaseSourceIntegration {\n  readonly id = 'acm';\n  readonly name = 'ACM Digital Library';\n\n  // URL patterns for ACM articles\n  readonly urlPatterns = [\n    // Standard DOI URLs (handles various DOI formats including alphanumeric)\n    /dl\\.acm\\.org\\/doi\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    /dl\\.acm\\.org\\/doi\\/abs\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    /dl\\.acm\\.org\\/doi\\/full\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    /dl\\.acm\\.org\\/doi\\/pdf\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    /dl\\.acm\\.org\\/doi\\/epdf\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // Legacy citation URLs\n    /dl\\.acm\\.org\\/citation\\.cfm\\?id=(\\d+)/,\n    /dl\\.acm\\.org\\/citation\\.cfm\\?.*doid=[\\d.]+\\.(\\d+)/,\n    // Proceeding URLs\n    /dl\\.acm\\.org\\/doi\\/proceedings\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // Book chapters\n    /dl\\.acm\\.org\\/doi\\/book\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // Generic ACM DL pattern\n    /dl\\.acm\\.org\\/doi\\//,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /dl\\.acm\\.org\\/(doi|citation)/.test(url);\n  }\n\n  /**\n   * Extract paper ID (DOI or citation ID) from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try DOI format (most common, handles alphanumeric DOIs)\n    const doiMatch = url.match(/dl\\.acm\\.org\\/doi\\/(?:abs|full|pdf|epdf|proceedings|book)?\\/?((10\\.\\d+\\/[^\\s?#]+))/);\n    if (doiMatch) {\n      return doiMatch[2] || doiMatch[1];\n    }\n\n    // Try legacy citation.cfm format\n    const legacyMatch = url.match(/citation\\.cfm\\?.*id=(\\d+)/);\n    if (legacyMatch) {\n      return legacyMatch[1];\n    }\n\n    // Try doid format\n    const doidMatch = url.match(/doid=[\\d.]+\\.(\\d+)/);\n    if (doidMatch) {\n      return doidMatch[1];\n    }\n\n    return null;\n  }\n\n  /**\n   * Create custom metadata extractor for ACM\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new ACMMetadataExtractor(document);\n  }\n}\n\n// Export singleton instance\nexport const acmIntegration = new ACMIntegration();\n","// extension/source-integration/acl/index.ts\n// ACL Anthology integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { MetadataExtractor } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('acl-integration');\n\n/**\n * Custom metadata extractor for ACL Anthology pages\n */\nclass ACLMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract title using citation meta tags\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') ||\n                      this.getMetaContent('meta[property=\"og:title\"]');\n    return metaTitle || super.extractTitle();\n  }\n\n  /**\n   * Extract authors from citation meta tags\n   */\n  protected extractAuthors(): string {\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    }\n\n    return super.extractAuthors();\n  }\n\n  /**\n   * Extract abstract/description\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"citation_abstract\"]') ||\n                            this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Extract publication date\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_date\"]') ||\n           super.extractPublishedDate();\n  }\n\n  /**\n   * Extract DOI\n   */\n  protected extractDoi(): string {\n    return this.getMetaContent('meta[name=\"citation_doi\"]') || super.extractDoi();\n  }\n\n  /**\n   * Extract conference name\n   */\n  protected extractJournalName(): string {\n    return this.getMetaContent('meta[name=\"citation_conference_title\"]') ||\n           this.getMetaContent('meta[name=\"citation_journal_title\"]') ||\n           super.extractJournalName();\n  }\n\n  /**\n   * Extract keywords/tags\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"citation_keywords\"]') ||\n                    this.getMetaContent('meta[name=\"keywords\"]');\n\n    if (keywords) {\n      return keywords.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n\n    return super.extractTags();\n  }\n}\n\n/**\n * ACL Anthology integration for computational linguistics papers\n */\nexport class ACLIntegration extends BaseSourceIntegration {\n  readonly id = 'acl';\n  readonly name = 'ACL Anthology';\n\n  // URL patterns for ACL Anthology papers (various formats)\n  readonly urlPatterns = [\n    // Current ACL Anthology format (e.g., 2023.acl-main.1)\n    /aclanthology\\.org\\/([A-Z0-9]+\\.\\d+-[a-z]+-\\d+)/i,\n    /aclanthology\\.org\\/([A-Z0-9]+\\.\\d+-\\d+)/,\n    // Older ACL Anthology format (e.g., P18-1001)\n    /aclanthology\\.org\\/([A-Z]\\d{2}-\\d+)/,\n    // Legacy aclweb.org URLs\n    /aclweb\\.org\\/anthology\\/([A-Z0-9]+\\.\\d+-\\d+)/,\n    /aclweb\\.org\\/anthology\\/([A-Z]\\d{2}-\\d+)/,\n    // PDF variants\n    /aclanthology\\.org\\/([^\\/]+)\\.pdf/,\n    // Volumes\n    /aclanthology\\.org\\/volumes\\/([^\\/\\s?#]+)/,\n    // Generic ACL patterns\n    /aclanthology\\.org\\/[A-Z0-9]/i,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /aclanthology\\.org\\/[A-Z0-9]/i.test(url) ||\n           /aclweb\\.org\\/anthology\\//.test(url);\n  }\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try new format (e.g., 2023.acl-main.1)\n    const newFormatMatch = url.match(/aclanthology\\.org\\/([A-Z0-9]+\\.[a-z0-9-]+)/i);\n    if (newFormatMatch) {\n      return newFormatMatch[1].replace(/\\.pdf$/, '');\n    }\n\n    // Try old format (e.g., P18-1001)\n    const oldFormatMatch = url.match(/(?:aclanthology|aclweb)\\.org\\/(?:anthology\\/)?([A-Z]\\d{2}-\\d+)/);\n    if (oldFormatMatch) {\n      return oldFormatMatch[1];\n    }\n\n    // Try volume format\n    const volumeMatch = url.match(/volumes\\/([^\\/\\s?#]+)/);\n    if (volumeMatch) {\n      return volumeMatch[1];\n    }\n\n    return null;\n  }\n\n  /**\n   * Create custom metadata extractor for ACL\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new ACLMetadataExtractor(document);\n  }\n}\n\n// Export singleton instance\nexport const aclIntegration = new ACLIntegration();\n","// extension/source-integration/neurips/index.ts\n// NeurIPS proceedings integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { MetadataExtractor } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('neurips-integration');\n\n/**\n * Custom metadata extractor for NeurIPS pages\n */\nclass NeurIPSMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract title using citation meta tags\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') ||\n                      this.getMetaContent('meta[property=\"og:title\"]');\n    return metaTitle || super.extractTitle();\n  }\n\n  /**\n   * Extract authors from citation meta tags\n   */\n  protected extractAuthors(): string {\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    }\n\n    // Fallback to HTML extraction\n    const authorElements = this.document.querySelectorAll('.author a, .author span');\n    if (authorElements.length > 0) {\n      return Array.from(authorElements)\n        .map(el => el.textContent?.trim())\n        .filter(Boolean)\n        .join(', ');\n    }\n\n    return super.extractAuthors();\n  }\n\n  /**\n   * Extract abstract/description\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"citation_abstract\"]') ||\n                            this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n\n    // NeurIPS often has abstract in a specific section\n    if (!metaDescription) {\n      const abstractSection = this.document.querySelector('.abstract');\n      if (abstractSection) {\n        return abstractSection.textContent?.trim() || '';\n      }\n    }\n\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Extract publication date\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_date\"]') ||\n           super.extractPublishedDate();\n  }\n\n  /**\n   * Extract conference name\n   */\n  protected extractJournalName(): string {\n    return this.getMetaContent('meta[name=\"citation_conference_title\"]') ||\n           'NeurIPS' ||\n           super.extractJournalName();\n  }\n\n  /**\n   * Extract keywords/tags\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"citation_keywords\"]') ||\n                    this.getMetaContent('meta[name=\"keywords\"]');\n\n    if (keywords) {\n      return keywords.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n\n    return super.extractTags();\n  }\n}\n\n/**\n * NeurIPS proceedings integration\n */\nexport class NeurIPSIntegration extends BaseSourceIntegration {\n  readonly id = 'neurips';\n  readonly name = 'NeurIPS';\n\n  // URL patterns for NeurIPS papers (multiple domains and formats)\n  readonly urlPatterns = [\n    // proceedings.neurips.cc (current main site)\n    /proceedings\\.neurips\\.cc\\/paper\\/(\\d+)\\/hash\\/([a-f0-9]+)/,\n    /proceedings\\.neurips\\.cc\\/paper\\/(\\d+)\\/file\\/([a-f0-9]+)/,\n    /proceedings\\.neurips\\.cc\\/paper_files\\/paper\\/(\\d+)\\/hash\\/([a-f0-9]+)/,\n    /proceedings\\.neurips\\.cc\\/paper_files\\/paper\\/(\\d+)\\/file\\/([a-f0-9]+)/,\n    // papers.nips.cc (legacy domain)\n    /papers\\.nips\\.cc\\/paper\\/(\\d+)\\/hash\\/([a-f0-9]+)/,\n    /papers\\.nips\\.cc\\/paper\\/(\\d+)\\/file\\/([a-f0-9]+)/,\n    /papers\\.nips\\.cc\\/paper_files\\/paper\\/(\\d+)\\/hash\\/([a-f0-9]+)/,\n    // Title-based URLs (older format)\n    /papers\\.nips\\.cc\\/paper\\/(\\d+)-([^\\/\\s]+)/,\n    /proceedings\\.neurips\\.cc\\/paper\\/(\\d+)-([^\\/\\s]+)/,\n    // Generic NeurIPS paper patterns\n    /proceedings\\.neurips\\.cc\\/paper/,\n    /papers\\.nips\\.cc\\/paper/,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /proceedings\\.neurips\\.cc\\/paper/.test(url) ||\n           /papers\\.nips\\.cc\\/paper/.test(url);\n  }\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try hash/file format (current)\n    const hashMatch = url.match(/paper(?:_files)?\\/paper\\/(\\d+)\\/(?:hash|file)\\/([a-f0-9]+)/);\n    if (hashMatch) {\n      return `${hashMatch[1]}-${hashMatch[2]}`;\n    }\n\n    // Try title-based format (older)\n    const titleMatch = url.match(/paper\\/(\\d+)-([^\\/\\s.]+)/);\n    if (titleMatch) {\n      return `${titleMatch[1]}-${titleMatch[2]}`;\n    }\n\n    // Try just year + anything\n    const yearMatch = url.match(/paper(?:_files)?\\/paper\\/(\\d+)\\/([^\\/\\s]+)/);\n    if (yearMatch) {\n      return `${yearMatch[1]}-${yearMatch[2]}`;\n    }\n\n    return null;\n  }\n\n  /**\n   * Create custom metadata extractor for NeurIPS\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new NeurIPSMetadataExtractor(document);\n  }\n}\n\n// Export singleton instance\nexport const neuripsIntegration = new NeurIPSIntegration();\n","// extension/source-integration/cvf/index.ts\n// CVF Open Access integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { MetadataExtractor } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('cvf-integration');\n\n/**\n * Custom metadata extractor for CVF pages\n */\nclass CVFMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract title using citation meta tags\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') ||\n                      this.getMetaContent('meta[property=\"og:title\"]');\n    return metaTitle || super.extractTitle();\n  }\n\n  /**\n   * Extract authors from citation meta tags\n   */\n  protected extractAuthors(): string {\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    }\n\n    // Fallback to HTML extraction\n    const authorElements = this.document.querySelectorAll('.author a, #authors b');\n    if (authorElements.length > 0) {\n      return Array.from(authorElements)\n        .map(el => el.textContent?.trim())\n        .filter(Boolean)\n        .join(', ');\n    }\n\n    return super.extractAuthors();\n  }\n\n  /**\n   * Extract abstract/description\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"citation_abstract\"]') ||\n                            this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n\n    // CVF has abstract in a specific div\n    if (!metaDescription) {\n      const abstractDiv = this.document.querySelector('#abstract');\n      if (abstractDiv) {\n        return abstractDiv.textContent?.trim() || '';\n      }\n    }\n\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Extract publication date\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_date\"]') ||\n           super.extractPublishedDate();\n  }\n\n  /**\n   * Extract conference name\n   */\n  protected extractJournalName(): string {\n    return this.getMetaContent('meta[name=\"citation_conference_title\"]') ||\n           super.extractJournalName();\n  }\n\n  /**\n   * Extract keywords/tags\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"citation_keywords\"]') ||\n                    this.getMetaContent('meta[name=\"keywords\"]');\n\n    if (keywords) {\n      return keywords.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n\n    return super.extractTags();\n  }\n}\n\n/**\n * CVF Open Access integration for CVPR, ICCV, WACV\n */\nexport class CVFIntegration extends BaseSourceIntegration {\n  readonly id = 'cvf';\n  readonly name = 'CVF Open Access';\n\n  // URL patterns for CVF papers (CVPR, ICCV, WACV, etc.)\n  readonly urlPatterns = [\n    // HTML paper pages\n    /openaccess\\.thecvf\\.com\\/content[_\\/]([A-Z]+)[_\\/](\\d+)[_\\/]html[_\\/]([^.]+)\\.html/i,\n    /openaccess\\.thecvf\\.com\\/content\\/([A-Z]+)(\\d+)[_\\/]html[_\\/]([^.]+)\\.html/i,\n    // PDF papers\n    /openaccess\\.thecvf\\.com\\/content[_\\/]([A-Z]+)[_\\/](\\d+)[_\\/]papers[_\\/]([^.]+)\\.pdf/i,\n    /openaccess\\.thecvf\\.com\\/content\\/([A-Z]+)(\\d+)[_\\/]papers[_\\/]([^.]+)\\.pdf/i,\n    // Workshop papers\n    /openaccess\\.thecvf\\.com\\/content[_\\/]([A-Z]+)[_\\/](\\d+)[_\\/]W\\d+[_\\/]html[_\\/]([^.]+)\\.html/i,\n    /openaccess\\.thecvf\\.com\\/content[_\\/]([A-Z]+)[_\\/](\\d+)[_\\/]W\\d+[_\\/]papers[_\\/]([^.]+)\\.pdf/i,\n    // Supplementary materials\n    /openaccess\\.thecvf\\.com\\/content[_\\/]([A-Z]+)[_\\/](\\d+)[_\\/]supplemental[_\\/]([^.]+)/i,\n    // Generic CVF content pattern\n    /openaccess\\.thecvf\\.com\\/content/,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /openaccess\\.thecvf\\.com\\/content/.test(url);\n  }\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try to extract conference, year, and paper name from various formats\n    // Format 1: content_CONF_YEAR/html/paper.html\n    const format1 = url.match(/content[_\\/]([A-Z]+)[_\\/](\\d+)[_\\/](?:W\\d+[_\\/])?(?:html|papers)[_\\/]([^.\\/]+)/i);\n    if (format1) {\n      return `${format1[1]}-${format1[2]}-${format1[3]}`;\n    }\n\n    // Format 2: content/CONFYEAR/html/paper.html\n    const format2 = url.match(/content\\/([A-Z]+)(\\d{4})[_\\/](?:W\\d+[_\\/])?(?:html|papers)[_\\/]([^.\\/]+)/i);\n    if (format2) {\n      return `${format2[1]}-${format2[2]}-${format2[3]}`;\n    }\n\n    // Fallback: just extract the paper name from the path\n    const fallback = url.match(/\\/([^\\/]+)\\.(?:html|pdf)$/);\n    if (fallback) {\n      return fallback[1];\n    }\n\n    return null;\n  }\n\n  /**\n   * Create custom metadata extractor for CVF\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new CVFMetadataExtractor(document);\n  }\n}\n\n// Export singleton instance\nexport const cvfIntegration = new CVFIntegration();\n","// extension/source-integration/wiley/index.ts\n// Wiley Online Library integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { MetadataExtractor } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('wiley-integration');\n\n/**\n * Custom metadata extractor for Wiley pages\n */\nclass WileyMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract title using citation meta tags\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') ||\n                      this.getMetaContent('meta[property=\"og:title\"]') ||\n                      this.getMetaContent('meta[name=\"dc.Title\"]');\n    return metaTitle || super.extractTitle();\n  }\n\n  /**\n   * Extract authors from citation meta tags\n   */\n  protected extractAuthors(): string {\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    }\n\n    return super.extractAuthors();\n  }\n\n  /**\n   * Extract abstract/description\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Extract publication date\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_online_date\"]') ||\n           this.getMetaContent('meta[name=\"dc.Date\"]') ||\n           super.extractPublishedDate();\n  }\n\n  /**\n   * Extract DOI\n   */\n  protected extractDoi(): string {\n    return this.getMetaContent('meta[name=\"citation_doi\"]') ||\n           this.getMetaContent('meta[name=\"dc.Identifier\"]') ||\n           super.extractDoi();\n  }\n\n  /**\n   * Extract journal name\n   */\n  protected extractJournalName(): string {\n    return this.getMetaContent('meta[name=\"citation_journal_title\"]') ||\n           this.getMetaContent('meta[name=\"dc.Source\"]') ||\n           super.extractJournalName();\n  }\n\n  /**\n   * Extract keywords/tags\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"citation_keywords\"]') ||\n                    this.getMetaContent('meta[name=\"keywords\"]');\n\n    if (keywords) {\n      return keywords.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n\n    return super.extractTags();\n  }\n}\n\n/**\n * Wiley Online Library integration\n */\nexport class WileyIntegration extends BaseSourceIntegration {\n  readonly id = 'wiley';\n  readonly name = 'Wiley Online Library';\n\n  // URL patterns for Wiley articles\n  readonly urlPatterns = [\n    // Standard DOI URLs\n    /onlinelibrary\\.wiley\\.com\\/doi\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    /onlinelibrary\\.wiley\\.com\\/doi\\/abs\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    /onlinelibrary\\.wiley\\.com\\/doi\\/full\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    /onlinelibrary\\.wiley\\.com\\/doi\\/pdf\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    /onlinelibrary\\.wiley\\.com\\/doi\\/epdf\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // Wiley society journals (e.g., physoc.onlinelibrary.wiley.com)\n    /\\w+\\.onlinelibrary\\.wiley\\.com\\/doi\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    /\\w+\\.onlinelibrary\\.wiley\\.com\\/doi\\/abs\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    /\\w+\\.onlinelibrary\\.wiley\\.com\\/doi\\/full\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // AGU Publications (agupubs)\n    /agupubs\\.onlinelibrary\\.wiley\\.com\\/doi\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // FEBS journals\n    /febs\\.onlinelibrary\\.wiley\\.com\\/doi\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // Generic Wiley DOI pattern\n    /onlinelibrary\\.wiley\\.com\\/doi\\//,\n    /\\.onlinelibrary\\.wiley\\.com\\/doi\\//,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /\\.?onlinelibrary\\.wiley\\.com\\/doi\\//.test(url);\n  }\n\n  /**\n   * Extract paper ID (DOI) from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try to extract DOI from URL path (handles all variants)\n    const doiMatch = url.match(/\\/doi\\/(?:abs|full|pdf|epdf)?\\/?((10\\.\\d+\\/[^\\s?#]+))/);\n    if (doiMatch) {\n      return doiMatch[2] || doiMatch[1];\n    }\n\n    return null;\n  }\n\n  /**\n   * Create custom metadata extractor for Wiley\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new WileyMetadataExtractor(document);\n  }\n}\n\n// Export singleton instance\nexport const wileyIntegration = new WileyIntegration();\n","// extension/source-integration/plos/index.ts\n// PLOS integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { MetadataExtractor } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('plos-integration');\n\n/**\n * Custom metadata extractor for PLOS pages\n */\nclass PLOSMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract title using citation meta tags\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') ||\n                      this.getMetaContent('meta[property=\"og:title\"]') ||\n                      this.getMetaContent('meta[name=\"dc.title\"]');\n    return metaTitle || super.extractTitle();\n  }\n\n  /**\n   * Extract authors from citation meta tags\n   */\n  protected extractAuthors(): string {\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    }\n\n    return super.extractAuthors();\n  }\n\n  /**\n   * Extract abstract/description\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Extract publication date\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_date\"]') ||\n           this.getMetaContent('meta[name=\"dc.date\"]') ||\n           super.extractPublishedDate();\n  }\n\n  /**\n   * Extract DOI\n   */\n  protected extractDoi(): string {\n    return this.getMetaContent('meta[name=\"citation_doi\"]') ||\n           this.getMetaContent('meta[name=\"dc.identifier\"]') ||\n           super.extractDoi();\n  }\n\n  /**\n   * Extract journal name\n   */\n  protected extractJournalName(): string {\n    return this.getMetaContent('meta[name=\"citation_journal_title\"]') ||\n           super.extractJournalName();\n  }\n\n  /**\n   * Extract keywords/tags\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"citation_keywords\"]') ||\n                    this.getMetaContent('meta[name=\"keywords\"]');\n\n    if (keywords) {\n      return keywords.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n\n    return super.extractTags();\n  }\n}\n\n/**\n * PLOS (Public Library of Science) integration\n */\nexport class PLOSIntegration extends BaseSourceIntegration {\n  readonly id = 'plos';\n  readonly name = 'PLOS';\n\n  // URL patterns for PLOS articles (all PLOS journals)\n  readonly urlPatterns = [\n    // Standard article URLs with DOI parameter\n    /journals\\.plos\\.org\\/\\w+\\/article\\?id=(10\\.\\d+\\/[^\\s&]+)/,\n    // URL encoded DOI format\n    /journals\\.plos\\.org\\/\\w+\\/article\\/info[:%]3Adoi[/%]2F(10\\.\\d+)/,\n    // Generic PLOS article URL (for canHandleUrl)\n    /journals\\.plos\\.org\\/\\w+\\/article/,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /journals\\.plos\\.org\\/\\w+\\/article/.test(url);\n  }\n\n  /**\n   * Extract paper ID (DOI) from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try to extract DOI from id parameter\n    const idMatch = url.match(/[?&]id=(10\\.\\d+\\/[^\\s&]+)/);\n    if (idMatch) {\n      return decodeURIComponent(idMatch[1]);\n    }\n\n    // Try URL encoded DOI format\n    const encodedMatch = url.match(/doi[/%]2F(10\\.\\d+[/%]2F[^\\s&]+)/i);\n    if (encodedMatch) {\n      return decodeURIComponent(encodedMatch[1].replace(/%2F/gi, '/'));\n    }\n\n    // Fallback: generate from URL\n    return null;\n  }\n\n  /**\n   * Create custom metadata extractor for PLOS\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new PLOSMetadataExtractor(document);\n  }\n}\n\n// Export singleton instance\nexport const plosIntegration = new PLOSIntegration();\n","// extension/source-integration/biorxiv/index.ts\n// bioRxiv integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { MetadataExtractor } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('biorxiv-integration');\n\n/**\n * Custom metadata extractor for bioRxiv pages\n */\nclass BioRxivMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract title using citation meta tags\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') ||\n                      this.getMetaContent('meta[property=\"og:title\"]') ||\n                      this.getMetaContent('meta[name=\"DC.Title\"]');\n    return metaTitle || super.extractTitle();\n  }\n\n  /**\n   * Extract authors from citation meta tags\n   */\n  protected extractAuthors(): string {\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    }\n\n    return super.extractAuthors();\n  }\n\n  /**\n   * Extract abstract/description\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"citation_abstract\"]') ||\n                            this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Extract publication date\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_online_date\"]') ||\n           this.getMetaContent('meta[name=\"DC.Date\"]') ||\n           super.extractPublishedDate();\n  }\n\n  /**\n   * Extract DOI\n   */\n  protected extractDoi(): string {\n    return this.getMetaContent('meta[name=\"citation_doi\"]') ||\n           this.getMetaContent('meta[name=\"DC.Identifier\"]') ||\n           super.extractDoi();\n  }\n\n  /**\n   * Extract journal/venue name\n   */\n  protected extractJournalName(): string {\n    return this.getMetaContent('meta[name=\"citation_journal_title\"]') ||\n           'bioRxiv' ||\n           super.extractJournalName();\n  }\n\n  /**\n   * Extract keywords/tags\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"citation_keywords\"]') ||\n                    this.getMetaContent('meta[name=\"keywords\"]');\n\n    if (keywords) {\n      return keywords.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n\n    return super.extractTags();\n  }\n}\n\n/**\n * bioRxiv integration for preprints in biology\n */\nexport class BioRxivIntegration extends BaseSourceIntegration {\n  readonly id = 'biorxiv';\n  readonly name = 'bioRxiv';\n\n  // URL patterns for bioRxiv preprints\n  readonly urlPatterns = [\n    // DOI-based content URLs (most common)\n    /biorxiv\\.org\\/content\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // Early preprint URLs (legacy format)\n    /biorxiv\\.org\\/content\\/early\\/\\d+\\/\\d+\\/\\d+\\/(\\d+)/,\n    // Full/abs/pdf variants\n    /biorxiv\\.org\\/content\\/(10\\.\\d+\\/[^\\s?#]+)\\.full/,\n    /biorxiv\\.org\\/content\\/(10\\.\\d+\\/[^\\s?#]+)\\.abstract/,\n    /biorxiv\\.org\\/content\\/(10\\.\\d+\\/[^\\s?#]+)\\.pdf/,\n    // Collection URLs\n    /biorxiv\\.org\\/cgi\\/content\\/full\\/(\\d+)/,\n    /biorxiv\\.org\\/cgi\\/content\\/abstract\\/(\\d+)/,\n    // Generic content pattern\n    /biorxiv\\.org\\/content\\//,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /biorxiv\\.org\\/(content|cgi\\/content)\\//.test(url);\n  }\n\n  /**\n   * Extract paper ID (DOI or early ID) from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try DOI format (remove version suffix like v1, v2, etc.)\n    const doiMatch = url.match(/biorxiv\\.org\\/content\\/(10\\.\\d+\\/[^\\s?#.]+)/);\n    if (doiMatch) {\n      return doiMatch[1].replace(/v\\d+$/, '');\n    }\n\n    // Try early format\n    const earlyMatch = url.match(/early\\/\\d+\\/\\d+\\/\\d+\\/(\\d+)/);\n    if (earlyMatch) {\n      return earlyMatch[1];\n    }\n\n    // Try cgi format\n    const cgiMatch = url.match(/cgi\\/content\\/(?:full|abstract)\\/(\\d+)/);\n    if (cgiMatch) {\n      return cgiMatch[1];\n    }\n\n    return null;\n  }\n\n  /**\n   * Create custom metadata extractor for bioRxiv\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new BioRxivMetadataExtractor(document);\n  }\n}\n\n// Export singleton instance\nexport const bioRxivIntegration = new BioRxivIntegration();\n","// extension/source-integration/medrxiv/index.ts\n// medRxiv integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { MetadataExtractor } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('medrxiv-integration');\n\n/**\n * Custom metadata extractor for medRxiv pages\n */\nclass MedRxivMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract title using citation meta tags\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') ||\n                      this.getMetaContent('meta[property=\"og:title\"]') ||\n                      this.getMetaContent('meta[name=\"DC.Title\"]');\n    return metaTitle || super.extractTitle();\n  }\n\n  /**\n   * Extract authors from citation meta tags\n   */\n  protected extractAuthors(): string {\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    }\n\n    return super.extractAuthors();\n  }\n\n  /**\n   * Extract abstract/description\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"citation_abstract\"]') ||\n                            this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Extract publication date\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_online_date\"]') ||\n           this.getMetaContent('meta[name=\"DC.Date\"]') ||\n           super.extractPublishedDate();\n  }\n\n  /**\n   * Extract DOI\n   */\n  protected extractDoi(): string {\n    return this.getMetaContent('meta[name=\"citation_doi\"]') ||\n           this.getMetaContent('meta[name=\"DC.Identifier\"]') ||\n           super.extractDoi();\n  }\n\n  /**\n   * Extract journal/venue name\n   */\n  protected extractJournalName(): string {\n    return this.getMetaContent('meta[name=\"citation_journal_title\"]') ||\n           'medRxiv' ||\n           super.extractJournalName();\n  }\n\n  /**\n   * Extract keywords/tags\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"citation_keywords\"]') ||\n                    this.getMetaContent('meta[name=\"keywords\"]');\n\n    if (keywords) {\n      return keywords.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n\n    return super.extractTags();\n  }\n}\n\n/**\n * medRxiv integration for medical preprints\n */\nexport class MedRxivIntegration extends BaseSourceIntegration {\n  readonly id = 'medrxiv';\n  readonly name = 'medRxiv';\n\n  // URL patterns for medRxiv preprints\n  readonly urlPatterns = [\n    // DOI-based content URLs (most common)\n    /medrxiv\\.org\\/content\\/(10\\.\\d+\\/[^\\s?#]+)/,\n    // Early preprint URLs (legacy format)\n    /medrxiv\\.org\\/content\\/early\\/\\d+\\/\\d+\\/\\d+\\/(\\d+)/,\n    // Full/abs/pdf variants\n    /medrxiv\\.org\\/content\\/(10\\.\\d+\\/[^\\s?#]+)\\.full/,\n    /medrxiv\\.org\\/content\\/(10\\.\\d+\\/[^\\s?#]+)\\.abstract/,\n    /medrxiv\\.org\\/content\\/(10\\.\\d+\\/[^\\s?#]+)\\.pdf/,\n    // Collection URLs\n    /medrxiv\\.org\\/cgi\\/content\\/full\\/(\\d+)/,\n    /medrxiv\\.org\\/cgi\\/content\\/abstract\\/(\\d+)/,\n    // Generic content pattern\n    /medrxiv\\.org\\/content\\//,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /medrxiv\\.org\\/(content|cgi\\/content)\\//.test(url);\n  }\n\n  /**\n   * Extract paper ID (DOI or early ID) from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try DOI format (remove version suffix like v1, v2, etc.)\n    const doiMatch = url.match(/medrxiv\\.org\\/content\\/(10\\.\\d+\\/[^\\s?#.]+)/);\n    if (doiMatch) {\n      return doiMatch[1].replace(/v\\d+$/, '');\n    }\n\n    // Try early format\n    const earlyMatch = url.match(/early\\/\\d+\\/\\d+\\/\\d+\\/(\\d+)/);\n    if (earlyMatch) {\n      return earlyMatch[1];\n    }\n\n    // Try cgi format\n    const cgiMatch = url.match(/cgi\\/content\\/(?:full|abstract)\\/(\\d+)/);\n    if (cgiMatch) {\n      return cgiMatch[1];\n    }\n\n    return null;\n  }\n\n  /**\n   * Create custom metadata extractor for medRxiv\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new MedRxivMetadataExtractor(document);\n  }\n}\n\n// Export singleton instance\nexport const medRxivIntegration = new MedRxivIntegration();\n","// extension/source-integration/ssrn/index.ts\n// SSRN integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { MetadataExtractor } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('ssrn-integration');\n\n/**\n * Custom metadata extractor for SSRN pages\n */\nclass SSRNMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract title using citation meta tags\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') ||\n                      this.getMetaContent('meta[property=\"og:title\"]');\n    return metaTitle || super.extractTitle();\n  }\n\n  /**\n   * Extract authors from citation meta tags\n   */\n  protected extractAuthors(): string {\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    }\n\n    return super.extractAuthors();\n  }\n\n  /**\n   * Extract abstract/description\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Extract publication date\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_online_date\"]') ||\n           super.extractPublishedDate();\n  }\n\n  /**\n   * Extract DOI if available\n   */\n  protected extractDoi(): string {\n    return this.getMetaContent('meta[name=\"citation_doi\"]') || super.extractDoi();\n  }\n\n  /**\n   * Extract journal/series name\n   */\n  protected extractJournalName(): string {\n    return this.getMetaContent('meta[name=\"citation_journal_title\"]') ||\n           'SSRN' ||\n           super.extractJournalName();\n  }\n\n  /**\n   * Extract keywords/tags\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"citation_keywords\"]') ||\n                    this.getMetaContent('meta[name=\"keywords\"]');\n\n    if (keywords) {\n      return keywords.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n\n    return super.extractTags();\n  }\n}\n\n/**\n * SSRN (Social Science Research Network) integration\n */\nexport class SSRNIntegration extends BaseSourceIntegration {\n  readonly id = 'ssrn';\n  readonly name = 'SSRN';\n\n  // URL patterns for SSRN papers\n  readonly urlPatterns = [\n    // Short URL format\n    /ssrn\\.com\\/abstract=(\\d+)/,\n    // Legacy sol3/papers.cfm format\n    /papers\\.ssrn\\.com\\/sol3\\/papers\\.cfm\\?abstract_id=(\\d+)/,\n    /papers\\.ssrn\\.com\\/sol3\\/papers\\.cfm\\?.*abstract_id=(\\d+)/,\n    // Delivery format\n    /papers\\.ssrn\\.com\\/sol3\\/Delivery\\.cfm.*abstractid=(\\d+)/i,\n    // Direct link format\n    /ssrn\\.com\\/(\\d{7,})/,\n    // DOI format\n    /dx\\.doi\\.org\\/10\\.2139\\/ssrn\\.(\\d+)/,\n    // Generic SSRN patterns\n    /ssrn\\.com\\/abstract/,\n    /papers\\.ssrn\\.com\\/sol3\\//,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /ssrn\\.com\\/(abstract|sol3|\\d{7})/.test(url) ||\n           /papers\\.ssrn\\.com\\/sol3\\//.test(url) ||\n           /doi\\.org\\/10\\.2139\\/ssrn/.test(url);\n  }\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try abstract= format\n    const abstractMatch = url.match(/abstract[=_]?(\\d+)/i);\n    if (abstractMatch) {\n      return abstractMatch[1];\n    }\n\n    // Try abstract_id= format\n    const abstractIdMatch = url.match(/abstract_id=(\\d+)/i);\n    if (abstractIdMatch) {\n      return abstractIdMatch[1];\n    }\n\n    // Try DOI format\n    const doiMatch = url.match(/10\\.2139\\/ssrn\\.(\\d+)/);\n    if (doiMatch) {\n      return doiMatch[1];\n    }\n\n    // Try direct numeric ID in URL path\n    const directMatch = url.match(/ssrn\\.com\\/(\\d{7,})/);\n    if (directMatch) {\n      return directMatch[1];\n    }\n\n    return null;\n  }\n\n  /**\n   * Create custom metadata extractor for SSRN\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new SSRNMetadataExtractor(document);\n  }\n}\n\n// Export singleton instance\nexport const ssrnIntegration = new SSRNIntegration();\n","// extension/source-integration/semanticscholar/index.ts\n// Semantic Scholar integration with custom metadata extractor\n\nimport { BaseSourceIntegration } from '../base-source';\nimport { MetadataExtractor } from '../metadata-extractor';\nimport { loguru } from '../../utils/logger';\n\nconst logger = loguru.getLogger('semanticscholar-integration');\n\n/**\n * Custom metadata extractor for Semantic Scholar pages\n */\nclass SemanticScholarMetadataExtractor extends MetadataExtractor {\n  /**\n   * Extract title using citation meta tags\n   */\n  protected extractTitle(): string {\n    const metaTitle = this.getMetaContent('meta[name=\"citation_title\"]') ||\n                      this.getMetaContent('meta[property=\"og:title\"]');\n    return metaTitle || super.extractTitle();\n  }\n\n  /**\n   * Extract authors from citation meta tags\n   */\n  protected extractAuthors(): string {\n    const citationAuthors: string[] = [];\n    this.document.querySelectorAll('meta[name=\"citation_author\"]').forEach(el => {\n      const content = el.getAttribute('content');\n      if (content) citationAuthors.push(content);\n    });\n\n    if (citationAuthors.length > 0) {\n      return citationAuthors.join(', ');\n    }\n\n    return super.extractAuthors();\n  }\n\n  /**\n   * Extract abstract/description\n   */\n  protected extractDescription(): string {\n    const metaDescription = this.getMetaContent('meta[name=\"description\"]') ||\n                            this.getMetaContent('meta[property=\"og:description\"]');\n    return metaDescription || super.extractDescription();\n  }\n\n  /**\n   * Extract publication date\n   */\n  protected extractPublishedDate(): string {\n    return this.getMetaContent('meta[name=\"citation_publication_date\"]') ||\n           this.getMetaContent('meta[name=\"citation_date\"]') ||\n           super.extractPublishedDate();\n  }\n\n  /**\n   * Extract DOI if available\n   */\n  protected extractDoi(): string {\n    return this.getMetaContent('meta[name=\"citation_doi\"]') || super.extractDoi();\n  }\n\n  /**\n   * Extract journal/venue name\n   */\n  protected extractJournalName(): string {\n    return this.getMetaContent('meta[name=\"citation_journal_title\"]') ||\n           this.getMetaContent('meta[name=\"citation_conference_title\"]') ||\n           super.extractJournalName();\n  }\n\n  /**\n   * Extract keywords/tags\n   */\n  protected extractTags(): string[] {\n    const keywords = this.getMetaContent('meta[name=\"citation_keywords\"]') ||\n                    this.getMetaContent('meta[name=\"keywords\"]');\n\n    if (keywords) {\n      return keywords.split(/[;,]/).map(tag => tag.trim()).filter(Boolean);\n    }\n\n    return super.extractTags();\n  }\n}\n\n/**\n * Semantic Scholar integration\n */\nexport class SemanticScholarIntegration extends BaseSourceIntegration {\n  readonly id = 'semanticscholar';\n  readonly name = 'Semantic Scholar';\n\n  // URL patterns for Semantic Scholar papers\n  readonly urlPatterns = [\n    // Standard paper URL with title slug and corpus ID\n    /semanticscholar\\.org\\/paper\\/[^/]+\\/([a-f0-9]+)/,\n    // Paper URL without title slug (direct ID)\n    /semanticscholar\\.org\\/paper\\/([a-f0-9]{40})/,\n    // CorpusID-based URL\n    /semanticscholar\\.org\\/paper\\/[^?]*[?&]corpusId=(\\d+)/,\n    // Reader URL\n    /semanticscholar\\.org\\/reader\\/([a-f0-9]+)/,\n    // Author paper pages\n    /semanticscholar\\.org\\/author\\/[^/]+\\/papers/,\n    // Generic paper pattern\n    /semanticscholar\\.org\\/paper\\//,\n  ];\n\n  /**\n   * Check if this integration can handle the given URL\n   */\n  canHandleUrl(url: string): boolean {\n    return /semanticscholar\\.org\\/(paper|reader)\\//.test(url);\n  }\n\n  /**\n   * Extract paper ID from URL\n   */\n  extractPaperId(url: string): string | null {\n    // Try to extract 40-character hex ID (SHA)\n    const shaMatch = url.match(/\\/([a-f0-9]{40})/);\n    if (shaMatch) {\n      return shaMatch[1];\n    }\n\n    // Try corpus ID from query params\n    const corpusMatch = url.match(/[?&]corpusId=(\\d+)/);\n    if (corpusMatch) {\n      return `corpus:${corpusMatch[1]}`;\n    }\n\n    // Try shorter hex ID format\n    const shortIdMatch = url.match(/semanticscholar\\.org\\/(?:paper|reader)\\/[^/]*\\/([a-f0-9]+)/);\n    if (shortIdMatch) {\n      return shortIdMatch[1];\n    }\n\n    return null;\n  }\n\n  /**\n   * Create custom metadata extractor for Semantic Scholar\n   */\n  protected createMetadataExtractor(document: Document): MetadataExtractor {\n    return new SemanticScholarMetadataExtractor(document);\n  }\n}\n\n// Export singleton instance\nexport const semanticScholarIntegration = new SemanticScholarIntegration();\n","// extension/source-integration/misc/index.ts\n/*\n * Catch-all for registering with URL pattern only\n * This integration handles papers from various academic sources not covered by specific integrations\n */\nimport { BaseSourceIntegration } from '../base-source';\n\nexport class MiscIntegration extends BaseSourceIntegration {\n  readonly id = 'url-misc';\n  readonly name = 'misc tracked url';\n\n  // URL patterns for link detection - these enable the annotation icon on matching links\n  readonly urlPatterns = [\n    // ScienceDirect\n    /sciencedirect\\.com\\/science\\/article\\//,\n    // PhilPapers\n    /philpapers\\.org\\/rec\\//,\n    // NeurIPS proceedings\n    /proceedings\\.neurips\\.cc\\/paper_files\\/paper\\//,\n    /papers\\.nips\\.cc\\/paper_files\\/paper\\//,\n    // Sage Journals\n    /journals\\.sagepub\\.com\\/doi\\//,\n    // Springer Link\n    /link\\.springer\\.com\\/article\\//,\n    // Science.org\n    /science\\.org\\/doi\\//,\n    // APS Journals\n    /journals\\.aps\\.org\\/\\w+\\/abstract\\//,\n    // Wiley\n    /onlinelibrary\\.wiley\\.com\\/doi\\//,\n    /physoc\\.onlinelibrary\\.wiley\\.com\\/doi\\//,\n    // Cell Press\n    /cell\\.com\\/.*\\/fulltext\\//,\n    // ResearchGate\n    /researchgate\\.net\\/publication\\//,\n    // APA PsycNET\n    /psycnet\\.apa\\.org\\/record\\//,\n    // bioRxiv/medRxiv\n    /biorxiv\\.org\\/content\\//,\n    /medrxiv\\.org\\/content\\//,\n    // OSF Preprints\n    /osf\\.io\\/preprints\\//,\n    // Frontiers\n    /frontiersin\\.org\\/journals?\\//,\n    /frontiersin\\.org\\/articles?\\//,\n    // JSTOR\n    /jstor\\.org\\/stable\\//,\n    // PMLR (Proceedings of Machine Learning Research)\n    /proceedings\\.mlr\\.press\\//,\n    // PLOS\n    /journals\\.plos\\.org\\/\\w+\\/article/,\n    // IEEE Xplore\n    /ieeexplore\\.ieee\\.org\\/document\\//,\n    /ieeexplore\\.ieee\\.org\\/abstract\\/document\\//,\n    // Royal Society\n    /royalsocietypublishing\\.org\\/doi\\//,\n    // PhilArchive\n    /philarchive\\.org\\/archive\\//,\n    // Taylor & Francis\n    /tandfonline\\.com\\/doi\\//,\n    // IOP Science\n    /iopscience\\.iop\\.org\\/article\\//,\n    // Oxford Academic\n    /academic\\.oup\\.com\\/\\w+\\/article/,\n    // eLife\n    /elifesciences\\.org\\/articles\\//,\n    // eScholarship\n    /escholarship\\.org\\/content\\//,\n    // PubMed Central\n    /pmc\\.ncbi\\.nlm\\.nih\\.gov\\/articles\\//,\n    /ncbi\\.nlm\\.nih\\.gov\\/pmc\\/articles\\//,\n    // PubMed\n    /pubmed\\.ncbi\\.nlm\\.nih\\.gov\\/\\d+/,\n    // CVF Open Access\n    /openaccess\\.thecvf\\.com\\/content/,\n    // Zenodo\n    /zenodo\\.org\\/records?\\//,\n    // ASM Journals\n    /journals\\.asm\\.org\\/doi\\//,\n    // BMJ\n    /bmj\\.com\\/content\\//,\n    // ACL Anthology\n    /aclanthology\\.org\\/[A-Z0-9.-]+\\//,\n    // AMS Journals\n    /journals\\.ametsoc\\.org\\/view\\/journals\\//,\n    // Substack (for academic newsletters)\n    /substack\\.com\\/p\\//,\n    // CiteSeerX\n    /citeseerx\\.ist\\.psu\\.edu\\//,\n    // Hugging Face Papers\n    /huggingface\\.co\\/papers\\//,\n    // Papers With Code\n    /paperswithcode\\.com\\/paper\\//,\n    // Google Scholar direct links\n    /scholar\\.google\\.com\\/scholar\\?.*cluster=/,\n    // SSRN\n    /papers\\.ssrn\\.com\\/sol3\\/papers\\.cfm/,\n    /ssrn\\.com\\/abstract=/,\n    // Cambridge Core\n    /cambridge\\.org\\/core\\/journals\\/.*\\/article\\//,\n    // Annual Reviews\n    /annualreviews\\.org\\/doi\\//,\n    // Generic DOI patterns\n    /\\/doi\\/(?:abs|full|pdf|epdf)?\\/?10\\.\\d+\\//,\n    // Generic PDF patterns (academic contexts)\n    /\\.pdf(?:\\?|$)/,\n  ];\n\n  // Content script matches - used for canHandleUrl checks\n  readonly contentScriptMatches = [\n    \"sciencedirect.com/science/article/\",\n    \"philpapers.org/rec/\",\n    \"proceedings.neurips.cc/paper_files/paper/\",\n    \"journals.sagepub.com/doi/\",\n    \"link.springer.com/article/\",\n    \".science.org/doi/\",\n    \"journals.aps.org/prx/abstract/\",\n    \"onlinelibrary.wiley.com/doi/\",\n    \"cell.com/trends/cognitive-sciences/fulltext/\",\n    \"researchgate.net/publication/\",\n    \"psycnet.apa.org/record/\",\n    \"biorxiv.org/content/\",\n    \"medrxiv.org/content/\",\n    \"osf.io/preprints/\",\n    \"frontiersin.org/journals/\",\n    \"frontiersin.org/articles/\",\n    \"jstor.org/stable/\",\n    \"proceedings.mlr.press/\",\n    \"journals.plos.org/plosone/article\",\n    \"ieeexplore.ieee.org/document/\",\n    \"royalsocietypublishing.org/doi/\",\n    \"papers.nips.cc/paper_files/paper/\",\n    \"philarchive.org/archive/\",\n    \"tandfonline.com/doi/\",\n    \"iopscience.iop.org/article/\",\n    \"academic.oup.com/brain/article/\",\n    \"elifesciences.org/articles/\",\n    \"escholarship.org/content/\",\n    \"pmc.ncbi.nlm.nih.gov/articles/\",\n    \"ncbi.nlm.nih.gov/pmc/articles/\",\n    \"pubmed.ncbi.nlm.nih.gov/\",\n    \"openaccess.thecvf.com/content/\",\n    \"zenodo.org/records/\",\n    \"journals.asm.org/doi/full/\",\n    \"physoc.onlinelibrary.wiley.com/doi/full/\",\n    \"storage.courtlistener.com/recap/\",\n    \"bmj.com/content/\",\n    \"ntsb.gov/investigations/pages\",\n    \"ntsb.gov/investigations/AccidentReports\",\n    \"aclanthology.org/\",\n    \"journals.ametsoc.org/view/journals/\",\n    \"huggingface.co/papers/\",\n    \"paperswithcode.com/paper/\",\n    \"papers.ssrn.com/\",\n    \"ssrn.com/abstract=\",\n    \"cambridge.org/core/journals/\",\n    \"annualreviews.org/doi/\",\n    \"substack.com/p/\",\n    \"citeseerx.\",\n    \"/doi/\",\n    \"/pdf/\",\n  ];\n\n  canHandleUrl(url: string): boolean {\n    // First check urlPatterns (regex)\n    if (this.urlPatterns.some(pattern => pattern.test(url))) {\n      return true;\n    }\n    // Then check contentScriptMatches (substring)\n    return this.contentScriptMatches.some(pattern => url.includes(pattern));\n  }\n}\n\nexport const miscIntegration = new MiscIntegration();\n","// extension/source-integration/registry.ts\n// Central registry for all source integrations\n\nimport { SourceIntegration } from './types';\nimport { arxivIntegration } from './arxiv';\nimport { openReviewIntegration } from './openreview';\nimport { natureIntegration } from './nature';\nimport { pnasIntegration } from './pnas';\nimport { scienceDirectIntegration } from './sciencedirect';\nimport { springerIntegration } from './springer';\nimport { ieeeIntegration } from './ieee';\nimport { acmIntegration } from './acm';\nimport { aclIntegration } from './acl';\nimport { neuripsIntegration } from './neurips';\nimport { cvfIntegration } from './cvf';\nimport { wileyIntegration } from './wiley';\nimport { plosIntegration } from './plos';\nimport { bioRxivIntegration } from './biorxiv';\nimport { medRxivIntegration } from './medrxiv';\nimport { ssrnIntegration } from './ssrn';\nimport { semanticScholarIntegration } from './semanticscholar';\nimport { miscIntegration } from './misc';\n\nexport const sourceIntegrations: SourceIntegration[] = [\n  arxivIntegration,\n  openReviewIntegration,\n  natureIntegration,\n  pnasIntegration,\n  scienceDirectIntegration,\n  springerIntegration,\n  ieeeIntegration,\n  acmIntegration,\n  aclIntegration,\n  neuripsIntegration,\n  cvfIntegration,\n  wileyIntegration,\n  plosIntegration,\n  bioRxivIntegration,\n  medRxivIntegration,\n  ssrnIntegration,\n  semanticScholarIntegration,\n  miscIntegration,\n];\n\n/*     *     *     *     */\n\nexport function getAllIntegrations(): SourceIntegration[] {\n  return sourceIntegrations;\n}\n\nexport function getIntegrationById(id: string): SourceIntegration | undefined {\n  return sourceIntegrations.find(integration => integration.id === id);\n}\n\nexport function getAllContentScriptMatches(): string[] {\n  return sourceIntegrations.flatMap(integration => integration.contentScriptMatches);\n}\n","// content.ts\n// Content script with simplified session tracking\n\nimport { LinkProcessor } from './source-integration/link-processor';\nimport { SourceIntegration, Message } from './source-integration/types';\nimport { PaperMetadata } from './papers/types';\nimport { loguru } from './utils/logger';\nimport { BaseSourceIntegration } from './source-integration/base-source';\nimport { generatePaperIdFromUrl } from './source-integration/metadata-extractor';\n\n// Import from registry instead of individual sources\nimport { sourceIntegrations } from './source-integration/registry';\n\nconst logger = loguru.getLogger('content-script');\n\nlogger.info('Paper Tracker content script loaded');\n\n// Base source for fallback processing\nconst baseSource = new BaseSourceIntegration();\n\n// Track active popup\nlet activePopup: HTMLElement | null = null;\n\n// Heartbeat interval\nlet heartbeatInterval: number | null = null;\nconst HEARTBEAT_INTERVAL = 5000; // 5 seconds\n\n// Track tab visibility\nlet isTabVisible = true;\n\n// Track current session\nlet currentSession: { sourceId: string; paperId: string } | null = null;\n\n// Create link processor\nconst linkProcessor = new LinkProcessor((sourceId, paperId, link) => {\n  // Callback when link is found\n  injectAnnotationButton(link, sourceId, paperId);\n});\n\n// Initialize sources\nfunction initializeSources() {\n  // Register each source with the link processor\n  for (const source of sourceIntegrations) {\n    logger.debug(`Initializing source: ${source.id}`);\n    \n    // Register patterns with link processor\n    source.urlPatterns.forEach(pattern => {\n      linkProcessor.registerPattern({\n        sourceId: source.id,\n        pattern,\n        extractPaperId: (url: string) => source.extractPaperId(url)\n      });\n    });\n  }\n}\n\n// Inject common styles\nfunction injectStyles() {\n  if (document.getElementById('paper-tracker-styles')) {\n    return; // Already injected\n  }\n  \n  const styles = `\n  .paper-annotator {\n    display: inline-block;\n    margin-left: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    opacity: 0.7;\n    transition: opacity 0.2s;\n    vertical-align: baseline;\n  }\n\n  .paper-annotator:hover {\n    opacity: 1;\n  }\n\n  .paper-popup-wrapper {\n    position: fixed;\n    z-index: 10000;\n  }\n\n  .paper-popup {\n    position: relative;\n    background: white;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n    padding: 12px;\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n    width: 300px;\n    box-sizing: border-box;\n  }\n\n  .paper-popup-header {\n    font-weight: bold;\n    margin-bottom: 8px;\n    line-height: 1.4;\n    font-size: 1em;\n  }\n\n  .paper-popup-meta {\n    color: #666;\n    font-size: 0.85em;\n    margin-bottom: 12px;\n    line-height: 1.4;\n  }\n\n  .paper-popup-buttons {\n    display: flex;\n    gap: 8px;\n    margin: 8px 0;\n  }\n\n  .paper-popup button {\n    padding: 6px 12px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    background: #f5f5f5;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    font-size: 0.9em;\n  }\n\n  .paper-popup button:hover {\n    background: #e8e8e8;\n    border-color: #ccc;\n  }\n\n  .paper-popup button.active {\n    background: #e0e0e0;\n    border-color: #aaa;\n  }\n\n  .paper-popup textarea {\n    width: calc(100% - 16px);\n    min-height: 80px;\n    margin: 8px 0;\n    padding: 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    resize: vertical;\n    font-family: inherit;\n    font-size: 0.9em;\n    line-height: 1.4;\n    box-sizing: border-box;\n  }\n\n  .paper-popup textarea:focus {\n    outline: none;\n    border-color: #aaa;\n  }\n\n  .paper-popup-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n    margin-top: 12px;\n  }\n\n  .paper-popup .save-button {\n    background: #2563eb;\n    color: white;\n    border-color: #2563eb;\n  }\n\n  .paper-popup .save-button:hover {\n    background: #1d4ed8;\n    border-color: #1d4ed8;\n  }\n  `;\n  \n  const styleSheet = document.createElement('style');\n  styleSheet.id = 'paper-tracker-styles';\n  styleSheet.textContent = styles;\n  document.head.appendChild(styleSheet);\n  \n  logger.debug('Injected styles');\n}\n\n// Add annotation button to link\nfunction injectAnnotationButton(link: HTMLAnchorElement, sourceId: string, paperId: string): void {\n  // Skip if already processed\n  if (link.nextSibling && \n      link.nextSibling.nodeType === Node.ELEMENT_NODE &&\n      (link.nextSibling as Element).classList.contains('paper-annotator')) {\n    return;\n  }\n  \n  // Create annotator button\n  const annotator = document.createElement('span');\n  annotator.className = 'paper-annotator';\n  annotator.textContent = '';\n  annotator.title = 'Add annotation';\n  \n  // Store data attributes\n  annotator.dataset.sourceId = sourceId;\n  annotator.dataset.paperId = paperId;\n  \n  // Add click handler\n  annotator.addEventListener('click', (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    \n    // Send message to background script to show popup\n    chrome.runtime.sendMessage({\n      type: 'showAnnotationPopup',\n      sourceId,\n      paperId,\n      position: {\n        x: e.clientX,\n        y: e.clientY\n      }\n    });\n  });\n  \n  // Add to page next to link\n  link.parentNode?.insertBefore(annotator, link.nextSibling);\n}\n\n// Get source that can handle a URL\nfunction getSourceForUrl(url: string): SourceIntegration | null {\n  for (const source of sourceIntegrations) {\n    if (source.canHandleUrl(url)) {\n      return source;\n    }\n  }\n  return null;\n}\n\n// Set up click-outside handler for popups\ndocument.addEventListener('click', (e) => {\n  if (activePopup && \n      !activePopup.contains(e.target as Node) && \n      !(e.target as Element).classList.contains('paper-annotator')) {\n    activePopup.parentElement?.remove();\n    activePopup = null;\n  }\n});\n\n// Start session tracking\nfunction startSessionTracking(sourceId: string, paperId: string) {\n  // Stop any existing heartbeat\n  stopHeartbeat();\n  \n  // Only start tracking if tab is visible\n  if (!isTabVisible) {\n    logger.debug(`Not starting session for ${sourceId}:${paperId} because tab is not visible`);\n    return;\n  }\n  \n  // Update current session\n  currentSession = { sourceId, paperId };\n  \n  // Tell background script to start a new session\n  chrome.runtime.sendMessage({\n    type: 'startSession',\n    sourceId,\n    paperId\n  }, response => {\n    if (response?.success) {\n      logger.debug(`Started session for ${sourceId}:${paperId}`);\n      \n      // Start sending heartbeats\n      startHeartbeat();\n    } else {\n      logger.error(`Failed to start session for ${sourceId}:${paperId}`, response?.error);\n    }\n  });\n}\n\n// Start sending heartbeats to background script\nfunction startHeartbeat() {\n  if (!currentSession) return;\n  \n  // Clear any existing interval\n  stopHeartbeat();\n  \n  // Set new interval\n  heartbeatInterval = window.setInterval(() => {\n    if (!currentSession) return;\n    \n    chrome.runtime.sendMessage({\n      type: 'sessionHeartbeat',\n      sourceId: currentSession.sourceId,\n      paperId: currentSession.paperId,\n      timestamp: Date.now()\n    });\n  }, HEARTBEAT_INTERVAL);\n  \n  logger.debug(`Started heartbeat for ${currentSession.sourceId}:${currentSession.paperId}`);\n}\n\n// Stop sending heartbeats\nfunction stopHeartbeat() {\n  if (heartbeatInterval !== null) {\n    clearInterval(heartbeatInterval);\n    heartbeatInterval = null;\n    logger.debug('Stopped heartbeat');\n  }\n}\n\n// End the current session\nfunction endCurrentSession(reason: string) {\n  if (!currentSession) return;\n  \n  const { sourceId, paperId } = currentSession;\n  \n  // Stop heartbeat\n  stopHeartbeat();\n  \n  // Send end session message\n  chrome.runtime.sendMessage({\n    type: 'endSession',\n    sourceId,\n    paperId,\n    reason\n  }, response => {\n    logger.debug(`Ended session for ${sourceId}:${paperId}`, { reason });\n  });\n  \n  // Clear current session\n  currentSession = null;\n}\n\n// Process the current page\nasync function processCurrentPage(force: boolean = false): Promise<PaperMetadata | null> {\n  const url = window.location.href;\n  \n  // Find a source that can handle this URL\n  let source = getSourceForUrl(url);\n  \n  // If no source was found and force parameter is set, use base source\n  if (!source && force) {\n    logger.info(`No matching source found, but force parameter set. Using base source for: ${url}`);\n    source = baseSource;\n  }\n\n  // If we still don't have a source, return null\n  if (!source) {\n    logger.debug(`No source found for URL: ${url}`);\n    return null;\n  }\n\n  // Now that we have a source, extract the paperId\n  const paperId = source.extractPaperId(url);\n  if (!paperId) {\n    logger.info(`Unable to determine a paperId for url: ${url}`);\n    return null;\n  }\n  \n  try {\n    // Use source-specific extraction\n    const metadata = await source.extractMetadata(document, paperId);\n    \n    if (metadata) {\n      // Send metadata to background script\n      chrome.runtime.sendMessage({\n        type: 'paperMetadata',\n        metadata\n      });\n      \n      logger.debug(`Sent extracted metadata to background script for ${metadata.sourceId}:${metadata.paperId}`);\n      \n      // Start session tracking if tab is visible\n      if (isTabVisible) {\n        startSessionTracking(metadata.sourceId, metadata.paperId);\n      }\n      \n      return metadata;\n    }\n  } catch (error) {\n    logger.error(`Error extracting metadata for ${source.id}:${paperId}`, error);\n  }\n  \n  return null;\n}\n\n// Visibility change listener\ndocument.addEventListener('visibilitychange', () => {\n  const wasVisible = isTabVisible;\n  isTabVisible = document.visibilityState === 'visible';\n  \n  if (isTabVisible && !wasVisible) {\n    // Tab has become visible again - restart session\n    logger.info('Tab became visible again');\n    \n    // If we have a current session, restart it\n    if (currentSession) {\n      startSessionTracking(currentSession.sourceId, currentSession.paperId);\n    } else {\n      // Otherwise, try to process the page\n      processCurrentPage();\n    }\n  } else if (!isTabVisible && wasVisible) {\n    // Tab has become hidden - end current session\n    logger.info('Tab hidden');\n    if (currentSession) {\n      endCurrentSession('tab_hidden');\n    }\n  }\n});\n\n// Focus/blur listeners\nwindow.addEventListener('focus', () => {\n  if (!isTabVisible) return; // Don't restart if tab is hidden\n  \n  logger.info('Window gained focus');\n  \n  // If we have a current session, restart it\n  if (currentSession) {\n    startSessionTracking(currentSession.sourceId, currentSession.paperId);\n  } else {\n    // Otherwise, try to process the page\n    processCurrentPage();\n  }\n});\n\nwindow.addEventListener('blur', () => {\n  logger.info('Window lost focus');\n  \n  // End the current session\n  if (currentSession) {\n    endCurrentSession('window_blur');\n  }\n});\n\n// Inform background when page is unloaded\nwindow.addEventListener('beforeunload', () => {\n  if (currentSession) {\n    logger.info('Page unloading');\n    endCurrentSession('page_unload');\n  }\n});\n\n// Message handler for background script\nchrome.runtime.onMessage.addListener((message: any, sender, sendResponse) => {\n  logger.debug('Received message', message);\n\n  // Simple ping to check if content script is loaded\n  if (message.type === 'ping') {\n    sendResponse({ success: true, loaded: true });\n    return true;\n  }\n\n  if (message.type === 'extractPaperMetadata') {\n    logger.debug('Received request to force paper metadata extraction');\n    \n    // Use processCurrentPage with force=true to enable fallback extraction\n    processCurrentPage(true)\n      .then(metadata => {\n        if (metadata) {\n          sendResponse({ success: true, metadata });\n        } else {\n          sendResponse({ success: false, error: 'Failed to extract metadata' });\n        }\n      })\n      .catch(error => {\n        logger.error('Error extracting metadata', error);\n        sendResponse({ \n          success: false, \n          error: error instanceof Error ? error.message : 'Unknown error' \n        });\n      });\n    return true; // Will respond asynchronously\n  }\n  \n  if (message.type === 'showPopup') {\n    // Remove existing popup\n    if (activePopup) {\n      activePopup.parentElement?.remove();\n      activePopup = null;\n    }\n    \n    // Create popup wrapper\n    const wrapper = document.createElement('div');\n    wrapper.className = 'paper-popup-wrapper';\n    \n    // Position near click or element\n    if (message.position) {\n      wrapper.style.left = `${message.position.x}px`;\n      wrapper.style.top = `${message.position.y}px`;\n    }\n    \n    // Create popup\n    const popup = document.createElement('div');\n    popup.className = 'paper-popup';\n    popup.innerHTML = message.html;\n    \n    // Add to page\n    wrapper.appendChild(popup);\n    document.body.appendChild(wrapper);\n    \n    // Set up event handlers\n    if (message.handlers) {\n      for (const handler of message.handlers) {\n        const elements = popup.querySelectorAll(handler.selector);\n        elements.forEach(element => {\n          element.addEventListener(handler.event, () => {\n            chrome.runtime.sendMessage({\n              type: 'popupAction',\n              action: handler.action,\n              sourceId: message.sourceId,\n              paperId: message.paperId,\n              data: {\n                value: element.tagName === 'TEXTAREA' ? \n                  (element as HTMLTextAreaElement).value : \n                  (element as HTMLElement).getAttribute('data-vote'),\n                checked: element.tagName === 'INPUT' ? \n                  (element as HTMLInputElement).checked : undefined,\n                id: (element as HTMLElement).id\n              }\n            });\n          });\n        });\n      }\n    }\n    \n    // Save reference\n    activePopup = popup;\n    \n    sendResponse({ success: true });\n    return true;\n  }\n  \n  if (message.type === 'processPage') {\n    // Re-process the entire page\n    linkProcessor.processLinks(document);\n    processCurrentPage();\n    sendResponse({ success: true });\n    return true;\n  }\n});\n\n// Initialize\n(async function initialize() {\n  // Inject styles\n  injectStyles();\n  \n  // Initialize sources\n  initializeSources();\n  \n  // Process links\n  linkProcessor.processLinks(document);\n  \n  // Start observing for new links\n  linkProcessor.startObserving(document);\n  \n  // Set initial tab visibility\n  isTabVisible = document.visibilityState === 'visible';\n  \n  // Process current page\n  processCurrentPage();\n  \n  // Tell background script we're ready and what page we're on\n  chrome.runtime.sendMessage(\n    { \n      type: 'contentScriptReady', \n      url: window.location.href \n    },\n    (response) => {\n      if (response?.success) {\n        logger.debug('Background script acknowledged ready status');\n      }\n    }\n  );\n})();\n\n// Set up observer for URL changes (single page apps)\nlet lastUrl = location.href;\nnew MutationObserver(() => {\n  const url = location.href;\n  if (url !== lastUrl) {\n    // End any current session\n    if (currentSession) {\n      endCurrentSession('url_change');\n    }\n    \n    // Update URL and process new page\n    lastUrl = url;\n    processCurrentPage();\n  }\n}).observe(document, { subtree: true, childList: true });\n"],"names":["Logger","constructor","module","this","debug","message","data","console","undefined","info","warning","warn","error","loguru","getLogger","logger","SOURCE_TYPES","MetadataExtractor","document","url","location","href","getMetaContent","selector","element","querySelector","getAttribute","extract","metadata","title","extractTitle","authors","extractAuthors","description","extractDescription","publishedDate","extractPublishedDate","doi","extractDoi","journalName","extractJournalName","tags","extractTags","metaTitle","titleSelectors","text","textContent","trim","length","citationAuthors","querySelectorAll","forEach","el","content","push","dcCreators","dcCreator","citationAuthor","ogAuthor","join","authorSelectors","elements","cleaned","replace","result","metaDescription","abstractSelectors","metaDate","dateSelectors","datetime","looksLikeDate","some","pattern","test","metaDoi","doiFromUrl","extractDoiFromUrl","doiSelectors","doiMatch","match","doiPatterns","keywords","split","map","tag","isPdf","toLowerCase","endsWith","getSourceType","generatePaperId","generatePaperIdFromUrl","hash","i","charCodeAt","Math","abs","toString","toUpperCase","substring","BaseSourceIntegration","id","name","urlPatterns","contentScriptMatches","canHandleUrl","extractPaperId","createMetadataExtractor","extractMetadata","paperId","extractor","extracted","sourceType","sourceId","abstract","timestamp","Date","toISOString","rating","formatPaperId","parsePaperId","identifier","prefix","startsWith","legacyPrefix","formatObjectId","type","ArxivMetadataExtractor","apiMetadata","super","authorLinks","Array","from","link","filter","Boolean","datelineElement","dateText","dateMatch","subjects","arxivIntegration","API_BASE_URL","fetchFromApi","apiUrl","response","fetch","ok","status","xmlText","parser","DOMParser","entry","parseFromString","summary","published","authorElements","journalRef","categoryElements","pageMetadata","hasTitle","hasAuthors","hasAbstract","convertToPageMetadata","enhancedExtractor","mergedMetadata","OpenReviewMetadataExtractor","baseMetadata","find","includes","nextElementSibling","venueElements","venue","keywordsElement","keywordsValue","openReviewIntegration","idMatch","referentMatch","NatureMetadataExtractor","metaAuthors","natureIntegration","articleMatch","pnasIntegration","contentMatch","earlyMatch","ScienceDirectMetadataExtractor","scienceDirectIntegration","piiMatch","bookMatch","SpringerMetadataExtractor","springerIntegration","decodeURIComponent","IEEEMetadataExtractor","abstractDiv","keywordElements","ieeeIntegration","docMatch","arnumberMatch","pdfMatch","csdlMatch","ACMMetadataExtractor","acmIntegration","legacyMatch","doidMatch","ACLMetadataExtractor","aclIntegration","newFormatMatch","oldFormatMatch","volumeMatch","NeurIPSMetadataExtractor","abstractSection","neuripsIntegration","hashMatch","titleMatch","yearMatch","CVFMetadataExtractor","cvfIntegration","format1","format2","fallback","WileyMetadataExtractor","wileyIntegration","PLOSMetadataExtractor","plosIntegration","encodedMatch","BioRxivMetadataExtractor","bioRxivIntegration","cgiMatch","MedRxivMetadataExtractor","medRxivIntegration","SSRNMetadataExtractor","ssrnIntegration","abstractMatch","abstractIdMatch","directMatch","SemanticScholarMetadataExtractor","semanticScholarIntegration","shaMatch","corpusMatch","shortIdMatch","miscIntegration","sourceIntegrations","baseSource","activePopup","heartbeatInterval","isTabVisible","currentSession","linkProcessor","onLinkFound","patterns","observer","processedLinks","Set","registerPattern","processLinks","linkId","getLinkId","has","add","startObserving","disconnect","MutationObserver","mutations","newLinks","mutation","addedNodes","node","nodeType","Node","ELEMENT_NODE","tagName","observe","body","childList","subtree","path","getElementPath","current","siblings","parentElement","children","index","indexOf","unshift","stopObserving","nextSibling","classList","contains","annotator","createElement","className","dataset","addEventListener","e","preventDefault","stopPropagation","chrome","runtime","sendMessage","position","x","clientX","y","clientY","parentNode","insertBefore","injectAnnotationButton","startSessionTracking","stopHeartbeat","success","window","setInterval","now","startHeartbeat","clearInterval","endCurrentSession","reason","async","processCurrentPage","force","source","getSourceForUrl","target","remove","wasVisible","visibilityState","onMessage","addListener","sender","sendResponse","loaded","then","catch","Error","wrapper","style","left","top","popup","innerHTML","html","appendChild","handlers","handler","event","action","value","checked","getElementById","styleSheet","head","injectStyles","initializeSources","lastUrl"],"mappings":"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"}